<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Work with Data - NEON Education</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml" />
<link rel="alternate" type="text/html" href="http://localhost:4000" />
<updated>2015-03-25T22:48:26-06:00</updated>
<id>http://localhost:4000/</id>
<author>
  <name>NEON EDUCATION</name>
  <uri>http://localhost:4000/</uri>
  <email>lwasser@neoninc.org</email>
</author>

 
<entry>
  <title type="html"><![CDATA[Cheat sheets for R and Python, At Your Service.]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/R-Python/Cheatsheets/" />
  <id>http://localhost:4000/R-Python/R-and-Python-Cheatsheets</id>
  <published>2015-03-20T11:49:52-06:00</published>
  <updated>2015-03-20T11:49:52-06:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#coding-cheatsheets&quot;&gt;Coding Cheatsheets&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cheatsheets-for-r&quot;&gt;Cheatsheets for R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cheatsheets-for-python&quot;&gt;Cheatsheets for Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h1 id=&quot;coding-cheatsheets&quot;&gt;Coding Cheatsheets&lt;/h1&gt;
&lt;p&gt;I’ll admit it, i’m a huge fan of cheat sheets. I am often jumping between programs and languages and it’s insanely easy to get syntax mixed up. A running list is below. If you have others, share them in the comments below and i’ll add them to the list! Cheers!
~Leah&lt;/p&gt;

&lt;h1 id=&quot;cheatsheets-for-r&quot;&gt;Cheatsheets for R&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;This is a nice &lt;a href=&quot;http://flowingdata.com/2015/03/17/r-cheat-sheet-for-graphical-parameters/&quot; target=&quot;_blank&quot;&gt; cheatsheet for figures in R. Thanks to @flowingdata on twitter.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Rstudio has developed  &lt;a href=&quot;http://www.rstudio.com/resources/cheatsheets/?utm_content=buffer756d6&amp;amp;utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=buffer/&quot; target=&quot;_blank&quot;&gt;a series of cheat sheets&lt;/a&gt; that are pretty nice. My favorite is the data wrangling one!&lt;/li&gt;
  &lt;li&gt;Nic Webber shared this &lt;a href=&quot;http://www.rstudio.com/resources/cheatsheets/?utm_content=buffer756d6&amp;amp;utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=buffer/&quot; target=&quot;_blank&quot;&gt;R-Python-Matlab cheat sheet&lt;/a&gt;. This one is great if you’re like me and constantly jumping between programs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cheatsheets-for-python&quot;&gt;Cheatsheets for Python&lt;/h1&gt;
&lt;p&gt;oh, how sad. I haven’t discovered any as of yet. &lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/R-Python/Cheatsheets/&quot;&gt;Cheat sheets for R and Python, At Your Service.&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on March 20, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[R: Creating HDF5 Files in the R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/HDF5/Create-HDF5-In-R/" />
  <id>http://localhost:4000/HDF5/R-Create-Hierarchical-Data-Format-HDF5</id>
  <published>2015-01-29T08:22:52-07:00</published>
  <updated>2015-01-29T08:22:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#hdf5-in-r&quot;&gt;HDF5 in R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#create-an-hdf5-file-in-r&quot;&gt;Create an HDF5 File in R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#add-metdata-to-hdf5-files&quot;&gt;Add Metdata to HDF5 Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reading-data-from-an-hdf5-file&quot;&gt;Reading Data from an HDF5 File&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;strong&gt;R Skill Level: &lt;/strong&gt; intermediate

&lt;h3&gt;Goals / Objectives&lt;/h3&gt;
After completing this activity, you will:
&lt;ol&gt;
&lt;li&gt;Understand how HDF5 files can be created and structured in R using the rhfd libraries. &lt;/li&gt;
&lt;li&gt;Understand the 3 key HDF5 elements: the HDF5 file itself and groups and datasets.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;What You&#39;ll Need&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R or R studio installed and the R HDF5 libraries.&lt;/li&gt;
&lt;li&gt;Recommended Background: Consider reviewing the documentation for the &lt;a href=&quot;http://www.bioconductor.org/packages/release/bioc/manuals/rhdf5/man/rhdf5.pdf&quot; target=&quot;_blank&quot;&gt;RHDF5 libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;h3 id=&quot;a-brief-review---about-hdf5&quot;&gt;A Brief Review - About HDF5&lt;/h3&gt;
&lt;p&gt;The HDF5 file can store large, heterogeneous datasets that include metadata. It also supports efficient &lt;code&gt;data slicing&lt;/code&gt;, or extraction of particular subsets of a dataset which means that you don’t have to read  large files read into the computers memory / RAM in their entirety in order work with them. This saves a lot of time when working with with HDF5 data in &lt;code&gt;R&lt;/code&gt;. When HDF5 files contain spatial data, they can also be read directly into GIS programs such as &lt;code&gt;QGiS&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;Remember that the HDF5 format is a self-contained directory structure. We can compare this structure to the folders and files located on your computer. However, in HDF5 files  “directories” are called &lt;code&gt;groups&lt;/code&gt; and files are called &lt;code&gt;datasets&lt;/code&gt;. The HDF5 element itself is a file. Each element in an HDF5 file can have metadata attached to it making HDF5 files “self-describing”.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/HDF5/About/&quot;&gt;Read more about HDF5 here.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;hdf5-in-r&quot;&gt;HDF5 in R&lt;/h2&gt;

&lt;p&gt;To access HDF5 files in &lt;code&gt;R&lt;/code&gt;, you need base &lt;a href=&quot;http://www.hdfgroup.org/HDF5/release/obtain5.html#obtain&quot; target=&quot;_blank&quot;&gt;HDF5 libraries&lt;/a&gt; installed on your computer. It might also be useful to install &lt;a href=&quot;http://www.hdfgroup.org/products/java/hdfview/&quot; target=&quot;_blank&quot;&gt;the free HDF5 viewer&lt;/a&gt; which will allow you to explore the contents of an HDF5 file visually using a graphic interface. &lt;a href=&quot;/HDF5/Exploring-Data-HDFView/&quot;&gt;More about working with HDFview and a hands-on activity here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The package we’ll be using is &lt;code&gt;rhdf5&lt;/code&gt; which is part of the &lt;a href=&quot;http://www.bioconductor.org&quot; target=&quot;_blank&quot;&gt;Bioconductor&lt;/a&gt; suite of &lt;code&gt;R&lt;/code&gt; packages. If you haven’t installed this package before, you can use the first two lines of code below to install the package. Then use the library command to call the &lt;code&gt;library(&quot;rhdf5&quot;)&lt;/code&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#install rhdf5 package
source(&quot;http://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;rhdf5&quot;)
library(&quot;rhdf5&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://www.bioconductor.org/packages/release/bioc/vignettes/rhdf5/inst/doc/rhdf5.pdf&quot; target=&quot;_blank&quot;&gt;Read more about the &lt;code&gt;rhdf5&lt;/code&gt; package here.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-an-hdf5-file-in-r&quot;&gt;Create an HDF5 File in R&lt;/h2&gt;

&lt;p&gt;Let’s start by outlining the structure of the file that we want to create.  We’ll build a file called “sensorData.h5”, that will hold data for a set of sensors at three different locations. Each sensor takes three replicates of two different measurements, every minute. &lt;/p&gt;

&lt;p&gt;HDF5 allows us to organize and store data in many ways. Therefore we need to decide what type of structure is ideally suited to our data before creating the HDF5 file. To structure the HDF5 file, we’ll start at the file level. We will create a group for each sensor location. Within each location group, we will create two datasets containing temperature and precipitation data collected through time at each location.&lt;/p&gt;

&lt;p&gt;So it will look something like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HDF5 FILE (sensorData.H5)
    &lt;ul&gt;
      &lt;li&gt;Location_One (Group)
        &lt;ul&gt;
          &lt;li&gt;Temperature (Dataset)&lt;/li&gt;
          &lt;li&gt;Precipitation (Dataset)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Location_Two  (Group)
        &lt;ul&gt;
          &lt;li&gt;Temperature (Dataset)&lt;/li&gt;
          &lt;li&gt;Precipitation (Dataset)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Location_Three  (Group)
        &lt;ul&gt;
          &lt;li&gt;Temperature (Dataset)&lt;/li&gt;
          &lt;li&gt;Precipitation (Dataset)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s first create the HDF5 file and call it “sensorData.h5”. Next, we will add a group for each location to the file. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create hdf5 file
h5createFile(&quot;sensorData.h5&quot;)
#create group for location 1
h5createGroup(&quot;sensorData.h5&quot;, &quot;location1&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember from the discussion above that we want to create 3 location groups. The process of creating nested groups can be simplified with loops and nested loops. While the for loop below might seem excessive for adding three groups, it will become increasingly more efficient as we need to add more groups to our file. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create loops that will populate 2 additional location &quot;groups&quot; in our HDF5 file
l1 &amp;lt;- c(&quot;location2&quot;,&quot;location3&quot;)
for(i in 1:length(l1)){
  	  h5createGroup(&quot;sensorData.h5&quot;, l1[i])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s view the structure of our HDF5 file. We’ll use the &lt;code&gt;h5ls()&lt;/code&gt; function to do this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# View HDF5 File Structure
h5ls(&quot;sensorData.h5&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our group structure that will contain location information is now set-up. However, it doesn’t contain any data. Let’s simulate some data pretending that each sensor took replicate measurements for 100 minutes. We’ll add a 100 x 3 matrix that will be stored as a &lt;strong&gt;dataset&lt;/strong&gt; in our HDF5 file. We’ll populate this dataset with simulated data for each of our groups. We’ll use loops to create these matrices and then paste them into each location group within the HDF5 file as datasets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Add datasets to each group
for(i in 1:3){
  g &amp;lt;- paste(&quot;location&quot;,i,sep=&quot;&quot;)
  #populate matrix with dummy data
  #create precip dataset within each location group
  h5write(matrix(rnorm(300,2,1),ncol=3,nrow=100),file = &quot;sensorData.h5&quot;,paste(g,&quot;precip&quot;,sep=&quot;/&quot;))
  #create temperature dataset within each location group
  h5write(matrix(rnorm(300,25,5),ncol=3,nrow=100),file = &quot;sensorData.h5&quot;,paste(g,&quot;temp&quot;,sep=&quot;/&quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;understandig-complex-code&quot;&gt;Understandig Complex Code&lt;/h3&gt;
&lt;p&gt;Sometimes you may run into code that combines multiple functions into one line. It can be helpful to break the pieces of the code apart to understand their function. &lt;/p&gt;

&lt;p&gt;Let’s start with &lt;code&gt;matrix(rnorm(300,2,1),ncol=3,nrow=100)&lt;/code&gt;. This is telling R to create a matrix that has 3 columns and 100 rows. Do the following to figure out what it’s doing.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Paste &lt;code&gt;(g,&quot;temp&quot;,sep=&quot;/&quot;)&lt;/code&gt; into the R console. What is the result?&lt;/li&gt;
  &lt;li&gt;Paste &lt;code&gt;rnorm(300,2,1)&lt;/code&gt; into the console and see the result. &lt;/li&gt;
  &lt;li&gt;Type &lt;code&gt;g&lt;/code&gt; into the console and take note of the result.&lt;/li&gt;
  &lt;li&gt;Type help(norm) to understand what norm does. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;rnorm&lt;/code&gt; function creates a set of random numbers that fall into a normal distribution. You specify the mean and standard deviation of the dataset and R does the rest. Notice in this loop we are creating a “precip” and a “temp” dataset and pasting them into each location group (the loop iterates 3 times).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;h5write&lt;/code&gt; function is writing each matrix to a dataset in our HDF5 file (sensorData.h5). It is looking for the following arguments: &lt;code&gt;hrwrite(dataset,YourHdfFileName,LocationOfDatasetInH5File)&lt;/code&gt;. Therefore, the code: &lt;code&gt;(matrix(rnorm(300,2,1),ncol=3,nrow=100),file = &quot;sensorData.h5&quot;,paste(g,&quot;precip&quot;,sep=&quot;/&quot;))&lt;/code&gt; tells R to add a random matrix of values to the sensorData HDF5 file within the path called &lt;code&gt;g&lt;/code&gt;.  It also tells R to call the dataset within that group, “precip”. &lt;/p&gt;

&lt;h3 id=&quot;hdf5-file-structure&quot;&gt;HDF5 File Structure&lt;/h3&gt;
&lt;p&gt;Next, let’s check the file structure of the sensorData.h5 file. The &lt;code&gt;h5ls()&lt;/code&gt; command tells us what each element in the file is, group or dataset. It also identifies the dimensions and types of data stored within the datasets in the HDF5 file. In this case, the  precipitation and temperature datasets are of type ‘float’ and of dimensions 100 x 3 (100 rows by 3 columns).&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip:&lt;/strong&gt; It’s useful to learn about the different types of data that can be stored within R (and other objects). &lt;a href=&quot;http://www.burns-stat.com/documents/tutorials/impatient-r/more-r-key-objects/more-r-numbers/#twonum&quot; target=&quot;_blank&quot;&gt;Learn more about float vs integer data here&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# List file structure
h5ls(&quot;sensorData.h5&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;data-types-within-hdf5&quot;&gt;Data Types within HDF5&lt;/h3&gt;
&lt;p&gt;HDF5 files can hold mixed types of data. For example HDF5 files can store both strings and numbers in the same file. Each dataset in an HDF5 file can be its own type. For example a dataset can be composed of all integer values or it could be composed of all strings (characters). A group can contain a mix of string, and number based datasets.  However a dataset can also be mixed within the dataset containing a combination of numbers and strings. &lt;/p&gt;

&lt;h2 id=&quot;add-metdata-to-hdf5-files&quot;&gt;Add Metdata to HDF5 Files&lt;/h2&gt;

&lt;p&gt;Some metadata can be added to an HDF5 file in R by creating attributes in R objects before adding them to the HDF5 file. Let’s look at an example of how we do this. We’ll add the units of our data as an attribute of the R matrix before adding it to the HDF5 file. Note that &lt;code&gt;write.attributes = TRUE&lt;/code&gt; is needed when you write to the HDF5 file, in order to add metadata to the dataset.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Create matrix of &quot;dummy&quot; data
p1 &amp;lt;- matrix(rnorm(300,2,1),ncol=3,nrow=100)
# Add attribute to the matrix (units)
attr(p1,&quot;units&quot;) &amp;lt;- &quot;millimeters&quot;

# Write the R matrix to the HDF5 file 
h5write(p1,file = &quot;sensorData.h5&quot;,&quot;location1/precip&quot;,write.attributes=T)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;reading-data-from-an-hdf5-file&quot;&gt;Reading Data from an HDF5 File&lt;/h2&gt;
&lt;p&gt;We just learned how to create an HDF5 file and write information to the file. We use a different set of functions to read data from an HDF5 file. If &lt;code&gt;read.attributes&lt;/code&gt; is set to &lt;code&gt;TRUE&lt;/code&gt; when we read the data, then we can also see the metadata for the matrix. Furthermore, we can chose to read in a subset, like the first 10 rows of data, rather than loading the entire dataset into R.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Read in all data contained in the precipitation dataset 
l1p1 &amp;lt;- h5read(&quot;sensorData.h5&quot;,&quot;location1/precip&quot;,read.attributes=T)

# Read in first 10 lines of the data contained within the precipitation dataset 
l1p1s &amp;lt;- h5read(&quot;sensorData.h5&quot;,&quot;location1/precip&quot;,read.attributes = T,index = list(1:10,NULL))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;extra-credit-if-you-get-done-early&quot;&gt;Extra Credit If you get done early…&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Think about an application for HDF5 that you might have. Create a new HDF5 File that would support the data that you need to store. &lt;/li&gt;
  &lt;li&gt;Open the sensordata.H5 file in the HDFviewer.&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/HDF5/Create-HDF5-In-R/&quot;&gt;R: Creating HDF5 Files in the R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 29, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Working With Temperature Data Collected for Multiple Sites and Stored in  HDF5 Format in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/HDF5/Explore-HDF5-Using-R/" />
  <id>http://localhost:4000/HDF5/R-Explore-Viz-Hierarchical-Data-Format-HDF5</id>
  <published>2015-01-28T13:49:52-07:00</published>
  <updated>2015-01-28T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#working-with-neon-temporal-temperature-tower-data&quot;&gt;Working with NEON Temporal Temperature Tower Data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#examine-file-contents&quot;&gt;1. Examine File Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#slicing-data&quot;&gt;Slicing Data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#plotting-neon-temperature-data-extracted-from-an-hdf5-file-using-ggplot&quot;&gt;2 Plotting NEON Temperature Data Extracted from an HDF5 file Using GGPLOT&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#data-from-different-sites&quot;&gt;Data from different sites&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;p&gt;&lt;strong&gt;R Skill Level:&lt;/strong&gt; intermediate&lt;/p&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;h3&gt;Goals / Objectives&lt;/h3&gt;

After completing this activity, you will:
&lt;ol&gt;
&lt;li&gt; Know how to explore an HDF5 file and access groups and datasets in R.&lt;/li&gt;
&lt;li&gt; Understand the basics of manipulating big data sets using indexing, loops, and `dplyr`.&lt;/li&gt;
&lt;li&gt; Refine your data plotting skills using `GGPLOT` in `R`.&lt;/li&gt;
&lt;li&gt; Be exposed to and learn how to apply a variety of data manipulation tasks including identifying data types given a new dataset, string parsing, and working with / formatting date information.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;You will need:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R or R studio running on your computer. &lt;/li&gt;
&lt;li&gt;HDF5 libraries and associated packages as described in the &quot;getting started&quot; section below. &lt;/li&gt;
&lt;li&gt;Recommended Background: Consider reviewing the documentation for the &lt;a href=&quot;http://www.bioconductor.org/packages/release/bioc/manuals/rhdf5/man/rhdf5.pdf&quot; target=&quot;_blank&quot;&gt;RHDF5 libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Data to Download:&lt;/h3&gt;
&lt;a href=&quot;../../data/NEON_TowerDataD3_D10.hdf5&quot; target=&quot;_blank&quot; class=&quot;btn btn-success&quot;&gt;Download the National Ecological Observatory Network (NEON) Flux Tower Temperature data HERE &lt;/a&gt;

&lt;/div&gt;

&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;To access HDF5 files in R, you’ll need to first install the base &lt;a href=&quot;http://www.hdfgroup.org/HDF5/release/obtain5.html#obtain&quot;&gt;HDF5 libraries&lt;/a&gt;. It might also be useful to install &lt;a href=&quot;http://www.hdfgroup.org/products/java/hdfview/&quot;&gt;HDFview&lt;/a&gt; which will allow you to explore the contents of an HDF5 file visually using a graphic interface. &lt;/p&gt;

&lt;p&gt;The package we’ll be using is &lt;code&gt;rhdf5&lt;/code&gt; which is part of the &lt;a href=&quot;http://www.bioconductor.org&quot; target=&quot;_blank&quot;&gt;Bioconductor&lt;/a&gt; suite of &lt;code&gt;R&lt;/code&gt; packages. If you haven’t installed this package before, you can use the first two lines of code below to install. Then use the library command to call the &lt;code&gt;rhdf5&lt;/code&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Install rhdf5 packages
# source(&quot;http://bioconductor.org/biocLite.R&quot;)
# biocLite(&quot;rhdf5&quot;)
library(&quot;rhdf5&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;hdf5-quick-review&quot;&gt;HDF5 Quick Review&lt;/h3&gt;
&lt;p&gt;The HDF5 format is a self-contained directory structure. In HDF5 files though “directories” are called “&lt;strong&gt;groups&lt;/strong&gt;” and “&lt;strong&gt;files&lt;/strong&gt;” are called “datasets”. Each element in an hdf5 file can have metadata attached to it making HDF5 files “self-describing”.&lt;/p&gt;

&lt;h2 id=&quot;working-with-neon-temporal-temperature-tower-data&quot;&gt;Working with NEON Temporal Temperature Tower Data&lt;/h2&gt;
&lt;p&gt;In this activity, we’ll work with &lt;a href=&quot;http://neoninc.org/science-design/collection-methods/flux-tower-measurements&quot;&gt; temperature data collected using sensors on a flux tower&lt;/a&gt; by  &lt;a href=&quot;http://www.neoninc.org&quot; target=&quot;_blank&quot;&gt;the National Ecological Observatory Network (NEON) &lt;/a&gt;. NEON will provide 30 years of open ecological data.&lt;/p&gt;

&lt;p&gt;We’ll examine our HDF5 file as if we knew nothing about it. We will view its structure, extract metadata and visualize data contained within datasets in the HDF5 file. We will also use use loops and custom functions to efficiently examine data with a complex nested structure using advanced tools like &lt;code&gt;dplyr&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;examine-file-contents&quot;&gt;1. Examine File Contents&lt;/h2&gt;

&lt;p&gt;Often we don’t know the structure of an HDF5 file that we receive. This means that to work with the data, we’ll first need to explore the underlying file structure. Let’s explore a NEON flux tower data file in HDF5 format in R. We’ll examine the file contents using the R function, &lt;code&gt;h5ls&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Load file
#NOTE: be sure to adjust the path to match your file structure!
# Identify file path
f &amp;lt;- &quot;data/NEON_TowerDataD3_D10.hdf5&quot;
# View structure of file
h5ls(f,all=T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;h5ls&lt;/code&gt; returns the full, hierarchical file structure including the group name, the name of a particular node (which may be a group), the type, class and the dimensions of the object. In this case the class of the groups is compound. Compound class means there are mixed data types (e.g. some columns are strings and some columns are integer or floating point numbers)  contained within that group. The dimensions for each dataset are also returned. When the dataset is compound, the dimension returned is the number of elements (or rows in the matrix in this case).&lt;/p&gt;

&lt;h2 id=&quot;slicing-data&quot;&gt;Slicing Data&lt;/h2&gt;
&lt;p&gt;One major benefit of HDF5 files is the ability to subset or &lt;code&gt;slice&lt;/code&gt; out parts of the file. Data slicing is particularly useful and efficient if you’re dealing with large files (even gigabytes or more). Let’s extract some temperature data, collected at &lt;a href=&quot;http://neoninc.org/science-design/field-sites/ordway-swisher-biological-station&quot; target=&quot;_blank&quot;&gt;the NEON field site - Ordway Swisher Biological Station (OSBS)&lt;/a&gt; and plot it.&lt;/p&gt;

&lt;p&gt;Remember that we are dealing with &lt;strong&gt;hierarchical data&lt;/strong&gt;. In this case we have a nested group and dataset structure. Below, we will slice out temperature data which is located within the following path:
 Domain_03 –&amp;gt; OSBS –&amp;gt; min_1 –&amp;gt; boom_1 –&amp;gt;temperature&lt;/p&gt;

&lt;p&gt;Take note that there are 4 groups and one dataset called temperature in this part of the HDF5 file as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Domain_03&lt;/strong&gt; - A NEON domain is an ecologically unique region. Domain 3 is one of 20 regions that &lt;a href=&quot;http://neoninc.org/science-design/spatiotemporal-design&quot; target=&quot;_blank&quot;&gt;NEON uses to organize its network spatially &lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OSBS&lt;/strong&gt; - a group representing data from the &lt;a href=&quot;http://neoninc.org/science-design/field-sites/ordway-swisher-biological-station&quot; target=&quot;_blank&quot;&gt; Ordway Swisher Biological Station.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;min_1&lt;/strong&gt; - A group representing the mean temperature data value for every for one minute in time. Temperature data is often collected at high frequencies (20 hz or 20 measurements a second) or more. A typical data product derived from high frequency data is an average value - in this case, all measurements are averaged every minute.  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;boom_1&lt;/strong&gt; - Boom 1 is the first and lowest arm or level on the tower. Towers often contain arms where the sensors are mounted, that reach out horizontally away from the tower (see figure below). The tower at Ordway Swisher has a total of 6 booms (booms 1-5 and the tower top). &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Note:&lt;/strong&gt; The data used in this activity were collected by a temperature sensor mounted on a National Ecological Observatory Network (NEON) “flux tower”. 
&lt;a href=&quot;http://neoninc.org/science-design/collection-methods/flux-tower-measurements&quot; target=&quot;_blank&quot;&gt;Read more about NEON towers, here. &lt;/a&gt;&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/NEONtower.png&quot;&gt;&lt;img src=&quot;/images/NEONtower.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;A NEON tower contains booms or arms that house sensors at varying heights along the tower.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;pre&gt;&lt;code&gt;#read in temperature data
temp &amp;lt;- h5read(f,&quot;/Domain_03/OSBS/min_1/boom_1/temperature&quot;)
#view the first few lines of the data 
head(temp)
#generate a quick plot of the data
plot(temp$mean,type=&#39;l&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/TempData.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can make our plot look nicer by adding date values to the x axis. However, in order to list dates o the X axis, we need to assign the date field a date format so that R knows how to read and organize the labels on the axis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Assign the date column a date format.
temp$date &amp;lt;- as.POSIXct(temp$date ,format = &quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;EST&quot;)

#load GGPLOT 
library(ggplot2)
#Create plot
ordwayPlot &amp;lt;- qplot (date,mean,data=temp,geom=&quot;line&quot;, title=&quot;ordwayData&quot;,
                 main=&quot;Mean Temperature Over 3 Days For Ordway Swisher Biological Station&quot;, xlab=&quot;Date&quot;, 
                 ylab=&quot;Mean Temperature (Degrees C)&quot;)

#let&#39;s check out the plot
ordwayPlot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your plot should look like this - pretty cool, right?:&lt;/p&gt;

&lt;iframe width=&quot;460&quot; height=&quot;345&quot; frameborder=&quot;0&quot; seamless=&quot;seamless&quot; scrolling=&quot;no&quot; src=&quot;https://plot.ly/~leahawasser/6.embed?width=460&amp;amp;height=345&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;extracting-metadata&quot;&gt;Extracting metadata&lt;/h3&gt;
&lt;p&gt;Remember in HDF5 files, metadata can be stored for all elements (the file itself, groups and datasets) in the HDF5 file. To read the metadata for elements in a file in R, you can use the &lt;code&gt;h5readAttributes&lt;/code&gt; function. We’ll work with this next.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Get names of elements in our file
fiu_struct &amp;lt;- h5ls(f,all=T)
## Concatenate the domain and the site names separated with a backslash
# This is the path to the metadata that we are interested in
g &amp;lt;- paste(fiu_struct[2,1:2],collapse=&quot;/&quot;)
# Check out the element g that was created above by printing it
print(g)
#  View the metadata for &quot;g&quot;
h5readAttributes(f,g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that you can work through the elements of the code above to understand it by typing each line into the console and examining the results. For instance, what happens when you type &lt;code&gt;fiu_struct[2,1:2]&lt;/code&gt; into the console?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Extra: Explore using the temperature data further using &lt;code&gt;h5ls&lt;/code&gt; . View attribute data for other groups within the file. If you have the HDFViewer installed, consider comparing what you get from are to what you see in the file visually using the HDFviewer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;end-part-1-&quot;&gt;&lt;strong&gt;**&lt;/strong&gt;* End Part 1 &lt;strong&gt;**&lt;/strong&gt;**&lt;/h3&gt;

&lt;h2 id=&quot;plotting-neon-temperature-data-extracted-from-an-hdf5-file-using-ggplot&quot;&gt;2 Plotting NEON Temperature Data Extracted from an HDF5 file Using GGPLOT&lt;/h2&gt;

&lt;p&gt;The NEON HDF5 file that we are working with contains temperature data collected for three days (a very small subset of the available data) using temperature sensors mounted on a towers located at two different &lt;a href=&quot;http://neoninc.org/science-design/field-sites&quot; target=&quot;_blank&quot;&gt;NEON field sites&lt;/a&gt;. What if we wanted to create a plot that compared data across sensors or sites? &lt;/p&gt;

&lt;h3 id=&quot;data-from-different-sensors-located-at-different-levels-at-one-neon-field-site&quot;&gt;Data From Different Sensors Located at Different Levels, At One NEON Field Site&lt;/h3&gt;

&lt;p&gt;To compare data, we’ll first need to loop through the HDF5 file and build a new data frame that contains temperature information over time, for each sensor or site. Let’s start by comparing temperature data collected by sensor located at different heights (on different boom arms on the tower), and averaged every 1 minute for the NEON Domain 3 site, Ordway Swisher Biological Station located in Florida.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Load libraries
library(dplyr)

# Set the path string
s &amp;lt;- &quot;/Domain_03/Ord/min_1&quot;

# Grab the paths to the data we want to use
paths &amp;lt;- fiu_struct %&amp;gt;% filter(grepl(s,group), 
     grepl(&quot;DATA&quot;,otype)) %&amp;gt;% group_by(group) %&amp;gt;% summarise(path = paste(group,name,sep=&quot;/&quot;))
#create a new blank data frame    
ord_temp &amp;lt;- data.frame()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code uses the powerful &lt;code&gt;dplyr&lt;/code&gt; libraries to filter data. Let’s break the code down. &lt;code&gt;dplyr&lt;/code&gt; is a package worth getting to know if you are working with big data. &lt;a href=&quot;http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html&quot; target=&quot;_blank&quot;&gt;Read more about the &lt;code&gt;dplyr&lt;/code&gt; package here&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;fiu_struct&lt;/code&gt;, defined above in the code, is the structure of our HDF5 file that we returned using &lt;code&gt;h5ls&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;grepl&lt;/code&gt; looks for a text pattern. Type &lt;code&gt;help(grepl)&lt;/code&gt; to see how it operates. We want to return all “paths” in the HDF file that match &lt;code&gt;s&lt;/code&gt; which we defined earlier as “/Domain_03/Ord/min_1”. Type &lt;code&gt;s&lt;/code&gt; into the console to see what comes up. &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;%&amp;gt;%&lt;/code&gt; is syntax specific to the &lt;code&gt;dplyr&lt;/code&gt; package. the &lt;code&gt;dplyr&lt;/code&gt; package contains functions that are used to query and subset data in different ways. The &lt;code&gt;%&amp;lt;%&lt;/code&gt; function allows you to ‘chain’ or combine multiple queries together into one, concise, line of code. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pulling this together, type, &lt;code&gt;fiu_struct %&amp;gt;% filter(grepl(s,group))&lt;/code&gt; in the console. This code will return a list of both datasets and groups for the Domain_03 site that contain the “/Domain_03/Ord/min_1” path. 
Now let’s review the second part of the code:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;grepl(&quot;DATA&quot;,otype))&lt;/code&gt; tells R to look for objects in the file that contain the word “data”. Type: &lt;code&gt;fiu_struct %&amp;gt;% filter(grepl(s,group), grepl(&quot;DATA&quot;,otype))&lt;/code&gt; in the console. Notice that this code returns the elements in the file that are both for the Ordway site AND are of type “dataset”.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;group_by(group) %&amp;gt;% summarise(path = paste(group,name,sep=&quot;/&quot;))&lt;/code&gt;: This code appends the group name (boom_1, boom_2, etc.) and the dataset name (temperature in this case) to the path.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next, we will create a loop that will populate the final &lt;code&gt;data.frame&lt;/code&gt; that contains information for all booms in the site that we want to plot.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#populate the ord_temp data frame using a for loop
for(i in paths$path){
 boom &amp;lt;-  strsplit(i,&quot;/&quot;)[[1]][5]
 dat &amp;lt;- h5read(f,i)
 dat$boom &amp;lt;- rep(boom,dim(dat)[1])
 ord_temp &amp;lt;- rbind(ord_temp,dat)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The loop above iterates through the file and grabs the temperature data for each boom in the 1 minute data series for Ordway. It also adds the boom name to the end of the &lt;code&gt;data.frame&lt;/code&gt; as follows: &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;for i in path$path&lt;/code&gt;. We have 5 “paths” total - one for each boom: booms 1,2,3,5 and the tower top. NOTE: the boom 4 sensor was not operational when this HDF5 file was created, which is why there is no boom 4 in our list! Thus we will need do iterate through the data 5 times&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;boom &amp;lt;-  strsplit(i,&quot;/&quot;)[[1]][5]&lt;/code&gt;: identify the name of the boom for iteration i. &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dat &amp;lt;- h5read(f,i)&lt;/code&gt;: read in the data from our hdf5 file (f) for iteration i (whichever iteration in the loop we are on) .&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dat$boom &amp;lt;- rep(boom,dim(dat)[1])&lt;/code&gt;: add the boom name as the final column in the dataset - column named “boom”&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;ord_temp &amp;lt;- rbind(ord_temp,dat)&lt;/code&gt;: append dataset to the end of the data.frame called ord_temp&lt;/p&gt;

    &lt;p&gt;EXTRA CREDIT: Modify the loop above so that it adds both the boom name, the site name and the data type (1 minute) as columns in our data frame.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cleaning-up-dates&quot;&gt;Cleaning Up Dates&lt;/h3&gt;
&lt;p&gt;The dates field in our data frame aren’t imported by default in “date format”. We need to tell R to format the information as a date. Formatting out date fields also allows us to properly label the x axis of our plots. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#format the date column as a date field. &quot;TZ:, time zone = Eastern Standard Time
ord_temp$date &amp;lt;- as.POSIXct(ord_temp$date,format = &quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;EST&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can make our plot of temperature for all booms on the tower! Notice we are using ggplot to do this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ggplot(ord_temp,aes(x=date,y=mean,group=boom,colour=boom))+geom_path()+ylab(&quot;Mean temperature&quot;) + xlab(&quot;Date&quot;)+theme_bw()+ggtitle(&quot;3 Days of temperature data at Ordway Swisher Biological Station&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/HDf5/ordwayPlot.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-from-different-sites&quot;&gt;Data from different sites&lt;/h2&gt;

&lt;p&gt;Next, let’s compare temperature at two different sites: Ordway Swisher Biological Station located in Florida and North Sterling located in Central Colorado. This time we’ll plot data averaged every 30 minutes instead of every minute. We’ll need to modify our search strings a bit. But we can still re-use most of the code that we just built.&lt;/p&gt;

&lt;p&gt;First, let’s extract all 30 minute averaged data, for all sites.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s &amp;lt;- &quot;min_30&quot;
# Grab the paths for all sites, 30 minute averaged data
paths &amp;lt;- fiu_struct %&amp;gt;% filter(grepl(s,group), grepl(&quot;DATA&quot;,otype)) %&amp;gt;% group_by(group) %&amp;gt;% summarise(path = paste(group,name,sep=&quot;/&quot;))

temp_30 &amp;lt;- data.frame()
for(i in paths$path){
  boom &amp;lt;-  strsplit(i,&quot;/&quot;)[[1]][5]
  site &amp;lt;- strsplit(i,&quot;/&quot;)[[1]][3]
  dat &amp;lt;- h5read(f,i)
  dat$boom &amp;lt;- rep(boom,dim(dat)[1])
  dat$site &amp;lt;- rep(site,dim(dat)[1])
 temp_30 &amp;lt;- rbind(temp_30,dat)
}

#Assign the date field to a &quot;date&quot; format in R
temp_30$date &amp;lt;- as.POSIXct(temp_30$date,format = &quot;%Y-%m-%d %H:%M:%S&quot;)

temp30_sum &amp;lt;- temp_30 %.% group_by(date,site) %&amp;gt;% summarise(mean = mean(mean))

#Create plot!
ggplot(temp30_sum,aes(x=date,y=mean,group=site,colour=site)) + geom_path()+ylab(&quot;Mean temperature, 30 Minute Average&quot;) + xlab(&quot;Date&quot;)+theme_bw()+ggtitle(&quot;Comparison of Ordway-Swisher Biological Station (FL) vs North Sterling (CO)&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/HDf5/OrdwaySterling.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Extra Credit: Create a plot of both sites with all booms at each site on the plot.&lt;/p&gt;
&lt;/blockquote&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/HDF5/Explore-HDF5-Using-R/&quot;&gt;Working With Temperature Data Collected for Multiple Sites and Stored in  HDF5 Format in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 28, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Raster Data in R - The Basics]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/R/Raster-Data-In-R/" />
  <id>http://localhost:4000/R/Raster-Data-In-R</id>
  <published>2015-01-26T13:49:52-07:00</published>
  <updated>2015-01-26T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#about-raster-data&quot;&gt;About Raster Data&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#about-utm&quot;&gt;About UTM&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#working-with-rasters-in-r&quot;&gt;Working with Rasters in R&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cropping-rasters-in-r&quot;&gt;Cropping Rasters in R&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#part-2---working-with-multiple-rasters-within-raster-stacks-and-raster-bricks&quot;&gt;Part 2 - Working with multiple rasters within Raster Stacks and Raster Bricks&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raster-bricks-in-r&quot;&gt;Raster Bricks in R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#write-a-raster-to-a-geotiff-file-in-r&quot;&gt;Write a raster to a Geotiff File in R&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;h3&gt;About&lt;/h3&gt;
This activity will walk you through the fundamental principles of working with raster data in R.
&lt;strong&gt;R Skill Level:&lt;/strong&gt; Intermediate

&lt;h3&gt;Goals / Objectives&lt;/h3&gt;
This activity is under development
After completing this activity, you will know:
&lt;ol&gt;
&lt;li&gt;what a raster dataset is and it&#39;s fundamental attributes.&lt;/li&gt;
&lt;li&gt;How to work with the raster package to import rasters into R&lt;/li&gt;
&lt;li&gt;How to perform basic calculations using rasters in R.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;What you&#39;ll Need&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R or R studio to write your code.&lt;/li&gt;
&lt;li&gt;GDAL libraries installed on you computer. &lt;a href=&quot;https://www.youtube.com/watch?v=ZqfiZ_J_pQQ&amp;amp;list=PLLWiknuNGd50NbvZhydbTqJJh5ZRkjuak&quot; target=&quot;_blank&quot;&gt;Click here for videos on installing GDAL on a MAC and a PC.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Data to Download&lt;/h3&gt;

Download the raster and *insitu* collected vegetation structure data:
&lt;b&gt;Part 1 data&lt;/b&gt;
&lt;a href=&quot;http://www.neonhighered.org/Data/LidarActivity/CHM_InSitu_Data.zip&quot; class=&quot;btn btn-success&quot;&gt; DOWNLOAD NEON  Sample NEON LiDAR Data&lt;/a&gt;
&lt;b&gt;Part 2 data&lt;/b&gt;
&lt;a href=&quot;http://www.neondataskills.org/data/rasterLayers_tif.zip&quot; class=&quot;btn btn-success&quot;&gt; DOWNLOAD NEON imagery data (tiff format) California Domain D17&lt;/a&gt;

&lt;p&gt;The LiDAR and imagery data used to create the rasters in this dataset were collected over the San Joachim field site located in California (NEON Domain 17) and processed at &lt;a href=&quot;http://www.neoninc.org&quot; target=&quot;_blank&quot;&gt;NEON &lt;/a&gt; headquarters. The entire dataset can be access by request from the NEON website.&lt;/p&gt;  

&lt;h3&gt;Pre-reqs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://neondataskills.org/HDF5/Working-With-Rasters/&quot;&gt;Please consider reading the background page on rasters, by clicking here.&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://cran.r-project.org/web/packages/raster/raster.pdf&quot; target=&quot;_blank&quot;&gt;Read more about the Raster Package in R.&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;h1 id=&quot;about-raster-data&quot;&gt;About Raster Data&lt;/h1&gt;
&lt;p&gt;Raster or “gridded” data are data that are saved in pixels. In the spatial world, each pixel represents an area “land” on the ground. For example in the raster below, each pixel represents a particular land cover class that would be found in that location in the real world. &lt;a href=&quot;http://neondataskills.org/HDF5/Working-With-Rasters/&quot;&gt;More on rasters here&lt;/a&gt;. &lt;/p&gt;

&lt;figure&gt;
   &lt;figcaption&gt;Raster showing land cover??&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;To work with rasters in R, you will want two key packages, &lt;code&gt;GDAL&lt;/code&gt; and &lt;code&gt;Raster&lt;/code&gt;. Let’s start by loading these into r. To install the raster package you can use &lt;code&gt;install.packages(‘raster’)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#load the raster and sp packages
library(raster)
library(sp)
#Set your working directory 
setwd(&quot;~/yourWorkingDirectoryHere&quot;)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let’s load the raster into R. Notice that we’re using some clever code that tells R to paste the working directory into the path, and then it tells it to add the location of the raster layer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#load raster in an R objected called &#39;DEM&#39;
DEM &amp;lt;- raster(paste(getwd(), &quot;/path here/SJER2013_DTM.tif&quot;, sep = &quot;&quot;))  # Tmin for January
#next, let&#39;s look at the attributes of the raster. 
DEM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class       : RasterLayer 
dimensions  : 5060, 4299, 21752940  (nrow, ncol, ncell)
resolution  : 1, 1  (x, y)
extent      : 254570, 258869, 4107302, 4112362  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 
data source : /Users/law/Documents/data/CHM_InSitu_Data/DigitalTerrainModel/SJER2013_DTMHill.tif 
names       : SJER2013_DTMHill 
values      : 0, 253  (min, max)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice a few things about this raster. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Nrow, Ncol&lt;/strong&gt; is the number of rows and columns data. &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ncells&lt;/strong&gt; is the total number of pixels that make up the raster.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Resolution&lt;/strong&gt; is the size of each pixel (in meters in this case)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Extent&lt;/strong&gt; this is the spatial extent of the raster. this value will be coordinate units associated with the coordinate reference system of the raster.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coord ref&lt;/strong&gt; this is the coordinate reference system string for the raster. This raster is in UTM (Universal Trans mercator) zone 11 with a datum of WGS 84. &lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system&quot; target=&quot;_blank&quot;&gt;More in UTM here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;about-utm&quot;&gt;About UTM&lt;/h2&gt;

&lt;figure&gt;
   &lt;a href=&quot;http://upload.wikimedia.org/wikipedia/en/thumb/5/57/Utm-zones.svg/720px-Utm-zones.svg.png
&quot;&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/en/thumb/5/57/Utm-zones.svg/720px-Utm-zones.svg.png
&quot; /&gt;&lt;/a&gt;
 &lt;figcaption&gt;The UTM coordinate reference system breaks the world into 60 latitude zones.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;working-with-rasters-in-r&quot;&gt;Working with Rasters in R&lt;/h2&gt;
&lt;p&gt;Now that we have the raster loaded into R, let’s grab some key metadata.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEM@crs
DEM@extent
#plot the raster
plot(DEM)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also notice it has a resolution and a set of dimension values associated with the raster. This means less work for us!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class       : RasterLayer 
dimensions  : 5060, 4299, 21752940  (nrow, ncol, ncell)
resolution  : 1, 1  (x, y)
extent      : 254570, 258869, 4107302, 4112362  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 
data source : /Users/law/Documents/data/CHM_InSitu_Data/DigitalSurfaceModel/SJER2013_DSM.tif 
names       : SJER2013_DSM 


#let&#39;s create a plot of our raster
plot(DEM)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;cropping-rasters-in-r&quot;&gt;Cropping Rasters in R&lt;/h1&gt;

&lt;p&gt;You can crop rasters in R using different methods. You can crop the raster right in the plot area. To do this, first plot the raster. Then define the crop extent by clicking twice: 1) click in the upper left hand corner where you want the crop box to begin. Then click again in the lower RIGHT hand corner where the box ends. you’ll see a red box on the plot. NOTE that this method is a manual process. But it’s cool to know how to do.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#first, click in the upper left hand corner where you want the crop to begin
# next click somewhere in the lower right hand corner to define the bottom right corner of your extent box you will see
#note: this is a manual process!
plot(DEM)
cropBox &amp;lt;- drawExtent()
#crop the raster then plot the new cropped raster
DEMcrop &amp;lt;- crop(DEM, cropBox)
plot(DEMcrop)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also manually assign the coordinate to use to crop. You’ll need the extent defined as (xmin,xmax,ymin,ymax) to do this. This is how you’d crop using a GIS shapefile (with a rectangular shape)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cropbox2 &amp;lt;-c(255077.3,257158.6,4109614,4110934)
DEMcrop2 &amp;lt;- crop(DEM, cropbox2)
plot(DEMcrop2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-2---working-with-multiple-rasters-within-raster-stacks-and-raster-bricks&quot;&gt;Part 2 - Working with multiple rasters within Raster Stacks and Raster Bricks&lt;/h2&gt;
&lt;p&gt;We’ve now loaded a raster into R. We’ve also made sure we knew the CRS (coordinate reference system) and extent of the dataset among other key metadata attributes. Next, let’s create a raster stack from 3 raster images.&lt;/p&gt;

&lt;p&gt;A raster stack is a collection of raster layers. Each raster layer in the stack needs to be in the same projection (CRS), spatial extent and resolution. You might use raster stacks for different reasons. For instance, you might want to group a time series of rasters representing precipitation or temperature into one R object. In part 2, we will stack 3 bands from a multi-band image together to create a final RGB image.&lt;/p&gt;

&lt;p&gt;The difficult way to do this is to load our rasters one at a time. But we’re over that!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import tiffs
band19 &amp;lt;- &quot;CHANGE-THIS-TO-PATH-ON-YOUR-COMPUTER/DigitalSurfaceModel/band19.tif&quot;
band34 &amp;lt;- &quot;CHANGE-THIS-TO-PATH-ON-YOUR-COMPUTER/DigitalSurfaceModel/band34.tif&quot;
band58 &amp;lt;- &quot;CHANGE-THIS-TO-PATH-ON-YOUR-COMPUTER/DigitalSurfaceModel/band58.tif&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also just use the list.files command to grab all of the files in a directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create list of files to make raster stack
#path to files
tifPath &amp;lt;- (paste(getwd(),&quot;/rasterLayers_tif&quot;,sep = &quot;&quot;))
rasterlist &amp;lt;- list.files(tifPath)

#create raster stack
rgbRaster &amp;lt;- stack(rasterlist)

#check to see that you&#39;ve created a raster stack and plot the layers
rgbRaster
plot(rgbRaster)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;a href=&quot;/images/GIS/rgbStackPlot.png&quot;&gt;&lt;img src=&quot;/images/GIS/rgbStackPlot.png&quot; /&gt;&lt;/a&gt;
 &lt;figcaption&gt;All rasters in the rasterstack plotted.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;You can also explore the data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#look at histogram of reflectance values for all rasters
hist(rgbRaster)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;a href=&quot;/images/GIS/RGBhist.png&quot;&gt;&lt;img src=&quot;/images/GIS/RGBhist.png&quot; /&gt;&lt;/a&gt;
 &lt;figcaption&gt;Histogram of reflectance values for each raster in the raster stack.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;pre&gt;&lt;code&gt;#remember that crop function? You can crop all rasters within a raster stack too
#finally you can crop all rasters within a raster stack!
rgbRaster_crop &amp;lt;- crop(rgbRaster, cropBox)
plot(rgbRaster_crop)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;a href=&quot;/images/GIS/cropRaster2.png&quot;&gt;&lt;img src=&quot;/images/GIS/cropRaster2.png&quot; /&gt;&lt;/a&gt;
 &lt;figcaption&gt;Histogram of reflectance values for each raster in the raster stack.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;raster-bricks-in-r&quot;&gt;Raster Bricks in R&lt;/h2&gt;
&lt;p&gt;Now we have a list of rasters in a stack. These rasters are all the same extent CRS and resolution but a raster brick will create one raster object in R that contains all of the rasters we can use this object to quickly create RGB images!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create raster brick
RGBbrick &amp;lt;- brick(rgbRaster)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;write-a-raster-to-a-geotiff-file-in-r&quot;&gt;Write a raster to a Geotiff File in R&lt;/h2&gt;

&lt;p&gt;We can write out the raster in tiff format as well. When we do this it will copy the CRS, extent and resolution information so the data will read properly into a GIS as well. Note that this writes the raster in the order they are in - in the stack. In this case, the blue (band 19) is first but it’s looking for the red band first (RGB). One way around this is to generate a new raster stack, ordering the rasters in the proper - red, green and blue format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Make a new stack in the order we want the data in:
finalRGBstack &amp;lt;- stack(rgbRaster$band58,rgbRaster$band34,rgbRaster$band19)
#write the geotiff
writeRaster(finalRGBstack,&quot;rgbRaster.tiff&quot;,&quot;GTiff&quot;, overwrite=TRUE)
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/R/Raster-Data-In-R/&quot;&gt;Raster Data in R - The Basics&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 26, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Working With Rasters in R, Python, QGIS and Other Tools]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/GIS-Spatial-Data/Working-With-Rasters/" />
  <id>http://localhost:4000/GIS-Spatial-Data/Working-With-Rasters-in-R-Python-GIS</id>
  <published>2015-01-15T13:49:52-07:00</published>
  <updated>2015-01-15T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#spatial-resolution&quot;&gt;Spatial Resolution&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spatial-extent&quot;&gt;Spatial Extent&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#coordinate-reference-system--projection-information&quot;&gt;Coordinate Reference System / Projection Information&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-makes-spatial-data-line-up-on-a-map&quot;&gt;What Makes Spatial Data Line Up On A Map?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reprojecting-data&quot;&gt;Reprojecting Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;div id=&quot;objectives&quot;&gt;
NOTE: this page is under development! We welcome any and all feedback!
&amp;gt; 
&lt;h3&gt;Goals / Objectives&lt;/h3&gt;

After completing this activity, you will:
&lt;ol&gt;
&lt;li&gt;Know the key attributes required to work with raster data including: spatial extent, coordinate reference system and spatial resolution.&lt;/li&gt;
&lt;li&gt;Understand what a spatial extent it.&lt;/li&gt;
&lt;li&gt;Generally understand spatial references of large raster data cubes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;You will need:&lt;/h3&gt;
A working thinking cap. This is an overview / background activity.
&lt;/div&gt;

&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;This activity with overview the key attributes that you need to extract for a raster dataset’s metadata in tools like R, Python and QGIS. Raster data, and raster data cubes can be organized and stored in many different ways. To understand raster datasets we often need to explore the data first to tease out key metadata or attributes including:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Spatial Resolution&lt;/li&gt;
  &lt;li&gt;Coordinate Reference System / Projection Information&lt;/li&gt;
  &lt;li&gt;Raster Extent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This post will overview the key components of hyperspectral remote sensing data that are required to begin working with the data in a tool like &lt;code&gt;R&lt;/code&gt; or &lt;code&gt;Python&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;spatial-resolution&quot;&gt;Spatial Resolution&lt;/h2&gt;
&lt;p&gt;A raster consists of a series of uniform pixels, each with the same dimension and shape. In the case of rasters derived from airborne sensors, each pixel represents an area of space on the ground. The size of the area on the ground that each pixel covers is known as the spatial resolution of the image. For instance, an image that has a 1m spatial resolution means that each pixel in the image represents a 1 m x 1 m area on the ground.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/hyperspectral/pixelDetail.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/pixelDetail.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;The spatial resolution of a raster refers the size of each cell in meters. This size in turn relates to the area on the ground that the pixel represents.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;spatial-extent&quot;&gt;Spatial Extent&lt;/h2&gt;
&lt;p&gt;The spatial extent of a raster, represents the “X, Y” coordinates of the corners of the raster in geographic space. This information, in addition to the cell size or spatial resolution, tells the program how to place or render each pixel in 2 dimensional space.  Tools like &lt;code&gt;R&lt;/code&gt;, using supporting packages such as &lt;code&gt;GDAL&lt;/code&gt; and associated raster tools often have comments that allow you to define the extent of a raster that is created within the tool. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#set raster extent (R Code)
#xMN = minimum x value, xMX=maximum x value, yMN - minimum Y value, yMX=maximum Y value
	rasExt &amp;lt;- extent(xMN,xMX,yMN,yMX)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/hyperspectral/sat_image_corners.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/sat_image_corners.png&quot; /&gt;&lt;/a&gt;
   
    &lt;figcaption&gt;To be located geographically, the images location needs to be defined in geographic space (on a spatial grid). The spatial extent defines the 4 corners of a raster, within a given coordinate reference system.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
	&lt;a href=&quot;/images/hyperspectral/sat_image_lat_lon.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/sat_image_lat_lon.png&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;The X and Y mins and max values relate to the coordinate system that the file is in (see below). &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;coordinate-reference-system--projection-information&quot;&gt;Coordinate Reference System / Projection Information&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A spatial reference system (SRS) or coordinate reference system (CRS) is a coordinate-based local, regional or global system used to locate geographical entities. – Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The earth is round. This is not an new concept by any means, however we need to remember this when we talk about coordinate reference systems associated with spatial data. When we make maps on paper or on a computer screen, we are moving from a 3 dimensional space (the globe) to 2 dimensions (our computer screens or a piece of paper). To keep this short, the projection of a dataset relates to how the data are “flattened” in geographic space so our human eyes and brains can make sense of the information in 2 dimensions. &lt;/p&gt;

&lt;p&gt;The projection refers to the mathematical calculations performed to “flatten the data” in into 2D space. The coordinate system references to the x and y coordinate space, that is associated with the projection used to flatten the data. If you have the same dataset, saved in two different projections, it won’t line up.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;https://source.opennews.org/media/cache/b9/4f/b94f663c79024f0048ae7b4f88060cb5.jpg&quot;&gt;&lt;img src=&quot;https://source.opennews.org/media/cache/b9/4f/b94f663c79024f0048ae7b4f88060cb5.jpg&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;Maps of the United States in different projections. Notice the differences in shape associated with each different projection. These differences are a direct result of the calculations used to &quot;flatten&quot; the data onto a 2 dimensional map. Source: opennews.org&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://source.opennews.org/en-US/learning/choosing-right-map-projection/&quot; target=&quot;_blank&quot;&gt;Read more about projections.&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-map-projections-can-fool-the-eye&quot;&gt;How Map Projections Can Fool the Eye&lt;/h4&gt;
&lt;p&gt;Check out this short video highlighting how map projections can make continents seems proportionally larger or smaller than they actually are!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/KUF_Ckv8HbE&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;what-makes-spatial-data-line-up-on-a-map&quot;&gt;What Makes Spatial Data Line Up On A Map?&lt;/h2&gt;
&lt;p&gt;There are lots of great resources that describe Coordinate Reference systems and projections in greater detail. However, for the purposes of this activity, what is important to understand is that data, from the same location, but saved in different projections &lt;strong&gt;will not line up in any GIS or other program&lt;/strong&gt;. Thus it’s important when working with spatial data in a program like &lt;code&gt;R&lt;/code&gt; or &lt;code&gt;Python&lt;/code&gt; to identify the coordinate reference system applied to the data, and to grab that information and retain it when you process / analyze the data.&lt;/p&gt;

&lt;h2 id=&quot;reprojecting-data&quot;&gt;Reprojecting Data&lt;/h2&gt;
&lt;p&gt;If you run into multiple spatial datasets with varying projections, you can always &lt;strong&gt;reproject&lt;/strong&gt; the data so that they are all in the same projection. Python and R both have reprojection tools that perform this task.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# reproject data to CRS of dataset2 in R
reprojectedData &amp;lt;- spTransform(dataset,CRS(proj4string(dataset2))) 
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/GIS-Spatial-Data/Working-With-Rasters/&quot;&gt;Working With Rasters in R, Python, QGIS and Other Tools&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 15, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Intro to Working with Hyperspectral Remote Sensing Data in HDF5 Format in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/HDF5/Imaging-Spectroscopy-HDF5-In-R/" />
  <id>http://localhost:4000/HDF5/Working-With-Hyperspectral-Data-In-R</id>
  <published>2015-01-14T13:49:52-07:00</published>
  <updated>2015-01-14T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#about-hyperspectral-remote-sensing-data&quot;&gt;About Hyperspectral Remote Sensing Data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#about-this-activity&quot;&gt;About This Activity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#read-hdf5-data-into-r&quot;&gt;1. Read HDF5 data into R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#create-a-georeferenced-raster&quot;&gt;2. Create a Georeferenced Raster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;strong&gt;R Skill Level:&lt;/strong&gt; Intermediate

&lt;h3&gt;Goals / Objectives&lt;/h3&gt;
After completing this activity, you will:
&lt;ol&gt;
&lt;li&gt;Understand how HDF5 data can be used to store spatial data and the associated benefits of this format when working with large spatial data cubes.&lt;/li&gt;
&lt;li&gt;Know how to extract metadata from HDF5 files.&lt;/li&gt;
&lt;li&gt;Know how to slice or subset HDF5 data. You will extract one band of pixels. &lt;/li&gt;
&lt;li&gt;Know how to plot a matrix as an image and a raster.&lt;/li&gt;
&lt;li&gt;Know how to export a final Geotiff (spatially projected) that can be used both in further analysis and in common GIS tools like QGIS.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;What you&#39;ll Need&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R or R studio to write your code.&lt;/li&gt;
&lt;li&gt;The latest version of RHDF5 packag for R.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Data to Download&lt;/h3&gt;
&lt;a href=&quot;http://neonhighered.org/Data/HDF5/SJER_140123_chip.h5&quot; class=&quot;btn btn-success&quot;&gt; DOWNLOAD the NEON Imaging Spectrometer Data (HDF5) Format&lt;/a&gt;. 
&lt;p&gt;The data in this HDF5 file were collected over the San Joachim field site located in California (NEON Domain 17) and processed at NEON headquarters. The entire dataset can be accessed &lt;a href=&quot;http://neoninc.org/data-resources/get-data/airborne-data&quot; target=&quot;_blank&quot;&gt;by request from the NEON website.&lt;/a&gt;
&lt;/p&gt;  
&lt;/div&gt;

&lt;h2 id=&quot;about-hyperspectral-remote-sensing-data&quot;&gt;About Hyperspectral Remote Sensing Data&lt;/h2&gt;

&lt;p&gt;The electromagnetic spectrum is composed of thousands of bands representing different types of light energy. Imaging spectrometers (instruments that collect hyperspectral data) break the electromagnetic spectrum into groups of bands that support classification of objects by their spectral properties on the earth’s surface. Hyperspectral data consists of many bands - up to hundreds of bands - that cover the electromagnetic spectrum.&lt;/p&gt;

&lt;p&gt;The NEON imaging spectrometer (NIS) collects data within the 380 nm to 2510 nm portions of the electromagnetic spectrum within bands that are approximately 5 nm in width. This results in a hyperspectral data cube that contains approximately 428 bands - which means BIG DATA. &lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/images/hyperspectral/DataCube.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/DataCube.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;A data cube of NEON hyperspectral data. Each layer in the cube represents a band.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The HDF5 data model natively compresses data stored within it (makes it smaller) and supports data slicing (extracting only the portions of the data that you need to work with rather than reading the entire dataset into memory). These features in addition to the ability to support spatial data and associated metadata make it ideal for working with large data cubes such as those generated by imaging spectrometers.&lt;/p&gt;

&lt;h2 id=&quot;about-this-activity&quot;&gt;About This Activity&lt;/h2&gt;
&lt;p&gt;In this activity we will explore reading and extracting spatial raster data stored within a HDF5 file using &lt;code&gt;R&lt;/code&gt;. Please be sure that you have &lt;em&gt;atleast&lt;/em&gt; version 2.10 of &lt;code&gt;rhdf5&lt;/code&gt; installed. Use: &lt;code&gt;packageVersion(&quot;rhdf5&quot;)&lt;/code&gt; to check the package version. If you need to update &lt;code&gt;rhdf5&lt;/code&gt;, use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source(&quot;http://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;rhdf5&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip:&lt;/strong&gt; To update all packages installed in &lt;code&gt;R&lt;/code&gt;, use &lt;code&gt;update.packages()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;read-hdf5-data-into-r&quot;&gt;1. Read HDF5 data into R&lt;/h2&gt;
&lt;p&gt;We will use the &lt;code&gt;raster&lt;/code&gt; and &lt;code&gt;rhdf5&lt;/code&gt; packages to read in the HDF5 file that contains hyperspectral data for the &lt;a href=&quot;http://neoninc.org/science-design/field-sites/san-joaquin&quot; target=&quot;_blank&quot;&gt;NEON San Joaquin field site&lt;/a&gt;. Let’s start by calling the needed libraries and reading in our NEON HDF5 file.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#r Load `raster` and `rhdf5` packages and read NIS data into R
library(raster)
library(rhdf5)
library(rgdal)
#load our file 
f &amp;lt;- &#39;/path/to/your/data/SJER_140123_chip.h5&#39;
#look at the HDF5 file structure 
h5ls(f,all=T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you look at the structure of the data, take note of the &lt;code&gt;map info dataset&lt;/code&gt;, the &lt;code&gt;spatial info&lt;/code&gt; group, and the &lt;code&gt;wavelengths&lt;/code&gt; and &lt;code&gt;reflectance&lt;/code&gt; datasets. The &lt;code&gt;spatial info&lt;/code&gt; folder contains the spatial attributes of the data including its Coordinate Reference System (CRS). The CRS documents how the data are physically location on the earth. The &lt;code&gt;wavelengths&lt;/code&gt; dataset contains the middle wavelength values for each band in the data. The reflectance dataset contains the image data that we will use for both data processing and visualization. &lt;/p&gt;

&lt;p&gt;More Information on raster metadata:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://neondataskills.org/HDF5/Working-With-Rasters/&quot; title=&quot;Key Attributes of Raster Data&quot;&gt;Metadata to understand when working with raster data&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://neondataskills.org/HDF5/About-Hyperspectral-Remote-Sensing-Data/&quot; title=&quot;Key Attributes of Raster Data&quot;&gt;Metadata and importa concepts associated with multi-band (multi and hyperspectral) rasters&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip - HDF5 Structure:&lt;/strong&gt; Note that the structure of individual HDF5 files may vary depending on who produced the data. In this case, the Wavelength and reflectance data within the file are both datasets. However the spatial information is contained within a group. Data downloaded from another organization like NASA, may look different. This is why it’s important to explore the data before diving into using it!&lt;/p&gt;

&lt;p&gt;We can use the &lt;code&gt;h5readAttributes&lt;/code&gt; function to read and extract metadata from the HDF5 file. Let’s start by reading in the spatial information.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#r get spatial info and map info using the h5readAttributes function 
#notes - this function was developed by the infamous Ted Hart.
spinfo &amp;lt;- h5readAttributes(f,&quot;spatialInfo&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let’s read in the wavelength center associated with each band in the HDF5 file. Which wavelength is band 19 associated with? (hint: look at the wavelengths vector that we just imported and check out the data located at index 19 - &lt;code&gt;wavelengths[19]&lt;/code&gt;).&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/hyperspectral/bluelight.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/bluelight.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;472 nanometers falls within the blue portion of the electromagnetic spectrum.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Band 19 has a associate wavelength center or 0.47244 which is in micrometers. This value equates to 472.44 nanometers (nm) which is in the visible blue portion of the electromagnetic spectrum (~ 400-700 nm). &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#get shape of the wavelength dataset (how many bands in the data?)
#get the dimensions of the wavelengths dataset in the H5 file
shapeWave&amp;lt;-dim(h5read(f,&quot;wavelength&quot;))
#read in the wavelength information from the Hdf5 file
wavelengths&amp;lt;- h5read(f,&quot;wavelength&quot;,index=list(1:shapeWave[1],shapeWave[2]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Bands and Wavelengths&lt;/strong&gt; A &lt;em&gt;band&lt;/em&gt; represents a group of wavelengths. For example, the wavelength values between 800nm and 805nm might be one band as captured by an imaging spectrometer. The imaging spectrometer collects reflected light energy in a pixel for light in that band. Often when you work with a multi or hyperspectral dataset, the band information is reported as the center wavelength value. This value represents the center point value of the wavelengths represented in that  band. Thus in a band spanning 800-805 nm, the center would be 802.5 nm). The full width half max (FWHM) will also be reported. This value represents the spread of the band around that center point. So, a band that covers 800 nm-805 nm might have a FWHM of 2.5 and a wavelength value of 802.5. &lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/hyperspectral/spectrumZoomed.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/spectrumZoomed.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;Bands represent a range of values (types of light) within the electromagnetic spectrum. Values for each band are often represented as the center point value of each band.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The HDF5 dataset that we are working with in this activity contains more information than we need to work with. For example, we don’t necessarily need to process all 426 bands - if we are interested in creating a product like NDVI which only users bands in the near infra-red and red portions of the spectrum. Or we might only be interested in a spatial subset of the data - perhaps a region where we have plots in the field.&lt;/p&gt;

&lt;p&gt;The HDF5 format allows us to slice (or subset) the data - quickly extracting the subset that we need to process. Let’s extract one of the green bands in our dataset - band 34. By the way - what is the center wavelength value associated with band 34? hint &lt;code&gt;wavelengths[34]&lt;/code&gt;. How do we know this band is a green band in the visible portion of the spectrum?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#get the dimensions of the reflectance dataset in the H5 file
shapeRefl&amp;lt;-dim(h5read(f,&quot;Reflectance&quot;))
#Extract or &quot;slice&quot; data for band 34 from the HDF5 file
b34&amp;lt;- h5read(f,&quot;Reflectance&quot;,index=list(1:shapeRefl[1],1:shapeRefl[2],34))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-note-about-data-slicing-in-hdf5&quot;&gt;A Note About Data Slicing in HDF5&lt;/h3&gt;
&lt;p&gt;Data slicing allows us to extract and work with subsets of the data rather than reading in the entire dataset into memory. Thus, in this case, we can extract and plot the green band without reading in all 426 bands of information. The ability to slice large datasets, makes HDF5 ideal for working with big data. 	&lt;/p&gt;

&lt;p&gt;Next, let’s convert our data from an array (more than 2 dimensions) to a matrix (just 2 dimensions). We need to have our data in a matrix format to plot it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Convert from array to matrix
b34 &amp;lt;- b34[,,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Arrays vs. Matrices&lt;/strong&gt; Arrays are matrices with more than 2 dimensions. When we say dimension, we are talking about the “z” associated with the data (imagine a series of tabs in a spreadsheet). Put the other way: matrices are arrays with only 2 dimensions. Arrays can have any number of dimensions one, two, ten or more. &lt;/p&gt;

&lt;p&gt;Here is a matrix that is 4 x 3 in size (4 rows and 3 columns):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Metric&lt;/th&gt;
      &lt;th&gt;species 1&lt;/th&gt;
      &lt;th&gt;species 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;total number&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;average weight&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;average length&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;3.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;average height&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Dimensions in Arrays&lt;/strong&gt; An array contains 1 or more dimensions in the “z” direction. For example, let’s say that we collected this same set of species data for every day in a 30 day month. We might then have a matrix like the one above for each day for a total of 30 days making a 4 x 3 x 30 array (this dataset has more than 2 dimensions). More on R object types &lt;a href=&quot;http://www.statmethods.net/input/datatypes.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;half&quot;&gt;
    &lt;a href=&quot;/images/R/matrix.png&quot;&gt;&lt;img src=&quot;/images/R/matrix.png&quot; /&gt;&lt;/a&gt;
    &lt;a href=&quot;/images/R/array.png&quot;&gt;&lt;img src=&quot;/images/R/array.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;Right: a matrix has only 2 dimensions. Left: an array has more than 2 dimensions.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Next, let’s look at the metadata for the reflectance data. When we do this, take note of 1) the scale factor and 2) the data ignore value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# look at the metadata for the reflectance dataset
h5readAttributes(f,&quot;Reflectance&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s plot the band 34 data. Plotting spatial data as a visual “data check” is a good idea to make sure processing is being performed correctly and all is well with the image. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image(log(b34))
#note - when R brings in the matrix, the dimensions are read in reverse order
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What do you notice about the image? It’s a bit dark and lacking any detail. What could be causing this? Let’s look at the distribution of reflectance values in our data to figure out what is going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Plot range of reflectance values as a histogram to view range
#and distribution of values.
hist(b34,breaks=40,col=&quot;darkmagenta&quot;)
#View values between 0 and 5000
hist(b34,breaks=40,col=&quot;darkmagenta&quot;,xlim = c(0, 5000))
hist(b34, breaks=40,col=&quot;darkmagenta&quot;,xlim = c(5000, 15000),ylim=c(0,100))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you’re examining the histograms above, keep in mind that reflectance values range between 0-1. The &lt;strong&gt;data scale factor&lt;/strong&gt; in the metadata tells us to divide all reflectance values by 10,000. Thus, a value of 5,000 equates to a reflectance value of 0.50. Storing data as integers (without decimal places) compared to floating points (with decimal places) creates a smaller file. You will see this done often when working with remote sensing data.  &lt;/p&gt;

&lt;p&gt;Notice in the data that there are some larger reflectance values (&amp;gt;5,000) that represent a smaller number of pixels. These pixels are skewing how the image renders.   &lt;/p&gt;

&lt;p&gt;Remember that the metadata for the &lt;code&gt;Reflectance&lt;/code&gt; dataset designated 15,000 as &lt;code&gt;data ignore value&lt;/code&gt;. Thus, let’s set all pixels with a value &amp;gt; 14,999 to &lt;code&gt;NA&lt;/code&gt; (no value). If we do this, R won’t try to render these pixels.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b34[b34 = 15000] &amp;lt;- NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Data Ignore Value&lt;/strong&gt; Image data in raster format will often contain a data ignore value and a scale factor. The data ignore value represents pixels where there are no data. Among other causes, no data values may be attributed to the sensor not collecting data in that area of the image or to processing results which yield null values. &lt;/p&gt;

&lt;p&gt;Our image still looks dark because R is trying to render all reflectance values between 0 and 14999 as if they were distributed equally in the histogram. However we know they are not distributed equally. There are many more values between 0-5000 then there are values &amp;gt;5000. The proper way to adjust our data would be what’s called an &lt;code&gt;image stretch&lt;/code&gt;. We will learn how to stretch our image data, later. For now, let’s run a log on the pixel reflectance values to factor out those larger values. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image(log(b34))
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Reflectance Values and Image Stretch&lt;/strong&gt; Images have a distribution of reflectance values. A typical image viewing program will render the values by distributing the entire range of reflectance values  across a range of “shades” that the monitor can render - between 0 and 255. However, often the distribution of reflectance values is not linear. For example, in the case of ur data, most of the reflectance values fall between 0 and 0.5. Yet there are a few values &amp;gt;1 that are heavily impacting the way the image is drawn on our monitor. Imaging processing programs like ENVI, QGIS and ArcGIS (and even Adobe Photoshop) allow you to adjust the stretch of the image. This is similar to adjusting the contrast and brightness in Photoshop. Read more about this topic: &lt;a href=&quot;http://www.r-s-c-c.org/node/241&quot; target=&quot;_blank&quot;&gt;About Image Stretch - RSCC&lt;/a&gt; and another link that discusses image stretch &lt;a href=&quot;http://www.r-s-c-c.org/node/240&quot; target=&quot;_blank&quot;&gt;Read more about linear image stretch discussion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The log applied to our image increases the contrast making it look more like an image. However, look at the images below. The top one is what our log adjusted image looks like when plotted. The bottom on is an RGB version of the same image. Notice a difference? &lt;/p&gt;

&lt;figure class=&quot;half&quot;&gt;
    &lt;a href=&quot;/images/hyperspectral/RGBImage_2.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/RGBImage_2.png&quot; /&gt;&lt;/a&gt;
    &lt;a href=&quot;/images/hyperspectral/SJER_Flipped.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/SJER_Flipped.png&quot; /&gt;&lt;/a&gt;
    &lt;figcaption&gt;LEFT: the image as it should look. RIGHT: the image that we outputted from the code above. Notice a difference?&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;pre&gt;&lt;code&gt;#We need to transpose x and y values in order for our final image to plot properly
b34&amp;lt;-t(b34)
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip: Transpose&lt;/strong&gt; in HDF5 view, notice that there are three data dimensions for this file: Bands x Rows x Columns. However, when R reads in the dataset, it reads them as: Columns x Bands x Rows. The data are flipped. We can quickly transpose the data to correct for this using the &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;transpose&lt;/code&gt; command in &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The orientation is rotated in our log adjusted image. This is because &lt;code&gt;R&lt;/code&gt; reads in matrices starting from the upper left hand corner. Whereas, most rasters read pixels starting from the lower left hand corner. In the next section, we will deal with this issue by creating a proper georeferenced (spatiall located) raster in R. The raster format will read in pixels following the same methods as other GIS and imaging processing software like QGIS and ENVI do.&lt;/p&gt;

&lt;h2 id=&quot;create-a-georeferenced-raster&quot;&gt;2. Create a Georeferenced Raster&lt;/h2&gt;
&lt;p&gt;Next, we will create a proper raster using the &lt;code&gt;b34&lt;/code&gt; matrix. The raster format will allow us to define and manage:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Image stretch&lt;/li&gt;
  &lt;li&gt;Coordinate reference system / spatial reference&lt;/li&gt;
  &lt;li&gt;Resolution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It will also account for the orientation issue discussed above.&lt;/p&gt;

&lt;p&gt;To create a raster in R, we need a few pieces of information, including: &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The coordinate reference system (CRS)&lt;/li&gt;
  &lt;li&gt;The location of the first pixel (located in the lower left hand corner of the raster). &lt;/li&gt;
  &lt;li&gt;The resolution or size of each pixel in the data. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First let’s grab the spatial information that we need from the HDF5 file. The CRS and associated information that is needed is stored in the &lt;code&gt;map info&lt;/code&gt; dataset. The map info string looks something like this: &lt;code&gt;&quot;UTM,1.000,1.000,256521.000,4112571.000,1.000000e+000,&lt;/code&gt;
&lt;code&gt;1.000000e+000,11,North,WGS-84,units=Meters&quot; &lt;/code&gt;. Notice that this information is separated by commas. We can use the &lt;code&gt;strsplit&lt;/code&gt; command in R to extract each element into a vector. The elements are position 4 and 5 represent the lower left hand corner of the raster. We need this information to define the raster’s extent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Populate the raster image extent value. 
#get the map info, split out elements
mapInfo&amp;lt;-h5read(f,&quot;map info&quot;)
#Extract each element of the map info information 
#so we can extract the lower left hand corner coordinates.
mapInfo&amp;lt;-unlist(strsplit(mapInfo, &quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we define the extents of our raster. The extents will be used to calculate the raster’s resolution. The lower left hand corner is located at mapInfo[4:5]. We can define the final raster dataset extent by adding the number of rows to the Y lower left hand corner coordinate and the number of columns in the &lt;code&gt;Reflectance&lt;/code&gt; dataset to the X lower left hand corner coordinate.   &lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/images/hyperspectral/sat_image_lat_lon.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/sat_image_lat_lon.png&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;The extent of a raster represents the spatial location of each corner. The coordinate units will be determined by the spatial projection / coordinate reference system that the data are in. Learn more by clicking on the link below. &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;http://neondataskills.org/HDF5/Working-With-Rasters/&quot;&gt;Learn more about raster attributes including extent, and coordinate reference systems here.&lt;/a&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define extents of the data using metadata and matrix attributes
xMN=as.numeric(mapInfo[4])
xMX=(xMN+(ncol(b34)))
yMX=as.numeric(mapInfo[5]) 
yMN=(yMN-(nrow(b34)))     
rasExt &amp;lt;- extent(xMN,xMX,yMN,yMX)

#define final raster with projection info 
#note that capitalization will throw errors on a MAC.
#if UTM is all caps it might cause an error!
b34r&amp;lt;-raster(b34, 
        crs=(spinfo$projdef))

#assign the spatial extent to the raster
extent(b34r) &amp;lt;- rasExt
#look at raster attributes
b34r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ve now created a raster from band 34 reflectance data. We can plot that data if we want using the &lt;code&gt;plot&lt;/code&gt; command. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;writeRaster(b34r,file=&quot;band34.tif&quot;,overwrite=TRUE)
#we&#39;re done with the H5 file - 
#close the H5 file
H5close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;extra-credit&quot;&gt;Extra Credit&lt;/h3&gt;
&lt;p&gt;If you get done early, experiment with &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Creating rasters from other bands in the dataset.&lt;/li&gt;
  &lt;li&gt;Varying the distribution of values in the image to mimic an image stretch. e.g. &lt;code&gt;b34[b34 &amp;gt; 6000 ] &amp;lt;- 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/HDF5/Imaging-Spectroscopy-HDF5-In-R/&quot;&gt;Intro to Working with Hyperspectral Remote Sensing Data in HDF5 Format in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 14, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Creating a Raster Stack from Hyperspectral Imagery in HDF5 Format in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/HDF5/Create-Raster-Stack-Spectroscopy-HDF5-In-R/" />
  <id>http://localhost:4000/HDF5/Creating-RasterStacks-RGB-Images-From-Hyperspectral_Remote_Sensing_Data</id>
  <published>2015-01-13T13:49:52-07:00</published>
  <updated>2015-01-13T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#about-this-activity&quot;&gt;About This Activity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#creating-a-raster-stack-in-r&quot;&gt;1. Creating a Raster Stack in R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#plotting-our-data-on-a-map&quot;&gt;2. Plotting our data on a map.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#raster-math---creating-ndvi-and-other-vegetation-indices-in-r&quot;&gt;3. Raster Math - Creating NDVI and other Vegetation Indices in R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extra-credit&quot;&gt;Extra Credit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;strong&gt;R Skill Level:&lt;/strong&gt; Intermediate

&lt;h3&gt;Goals / Objectives&lt;/h3&gt;
After completing this activity, you will:
&lt;ol&gt;
&lt;li&gt;Extract a &quot;slice&quot; of data from a hyperspectral data cube.&lt;/li&gt;
&lt;li&gt;Create a rasterstack in R which can then be used to create RGB images from bands in a hyperspectral data cube.&lt;/li&gt;
&lt;li&gt;Plot data spatially on a map.&lt;/li&gt;
&lt;li&gt;Create basic vegetation indices like NDVI using raster  based calculations in R.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;What you&#39;ll Need&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R or R studio to write your code.&lt;/li&gt;
&lt;li&gt;The latest version of RHDF5 package for R.&lt;/li&gt;
&lt;li&gt;Recommended Background: Consider reviewing the documentation for the &lt;a href=&quot;http://www.bioconductor.org/packages/release/bioc/manuals/rhdf5/man/rhdf5.pdf&quot; target=&quot;_blank&quot;&gt;RHDF5 libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Data to Download&lt;/h3&gt;
&lt;a href=&quot;http://neonhighered.org/Data/HDF5/SJER_140123_chip.h5&quot; class=&quot;btn btn-success&quot;&gt; DOWNLOAD the NEON Imaging Spectrometer Data (HDF5) Format&lt;/a&gt;. 
&lt;p&gt;The data in this HDF5 file were collected over the San Joachim field site located in California (NEON Domain 17) and processed at NEON headquarters. The entire dataset can be accessed &lt;a href=&quot;http://neoninc.org/data-resources/get-data/airborne-data&quot; target=&quot;_blank&quot;&gt;by request from the NEON website.&lt;/a&gt;
&lt;/p&gt;  

&lt;h3&gt;Pre-reqs&lt;/h3&gt;
&lt;p&gt;We highly recommend you work through the - Introduction to Working with hyperspectral data in R activity before moving on to this activity.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;about&quot;&gt;About&lt;/h2&gt;
&lt;p&gt;We often want to generate a 3 band image from multi or hyperspectral data. The most commonly recognized band combination is RGB which stands for Red, Green and Blue. RGB images are just like the images that your camera takes. But there are other band combinations that are useful too. For example, near infrared images emphasize vegetation and help us classify or identify where vegetation is located on the ground.&lt;/p&gt;

&lt;figure class=&quot;third&quot;&gt;
    &lt;a href=&quot;/images/hyperspectral/RGBImage_2.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/RGBImage_2.png&quot; /&gt;&lt;/a&gt;
    &lt;a href=&quot;/images/hyperspectral/NIR_G_B.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/NIR_G_B.png&quot; /&gt;&lt;/a&gt;
    &lt;a href=&quot;/images/hyperspectral/falseColor.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/falseColor.png&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;SJER image using 3 different band combinations. Left: typical red, green and blue (bands 58,34,19), middle: color infrared: near infrared, green and blue (bands 90, 34, 19).&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip - Band Combinations:&lt;/strong&gt; the Biodiversity Informatics group created a great interactive tool that lets you explore band combinations. Check it out:&lt;a href=&quot;http://biodiversityinformatics.amnh.org/interactives/bandcombination.php&quot; target=&quot;_blank&quot;&gt;Learn more about band combinations using a great online tool!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;about-this-activity&quot;&gt;About This Activity&lt;/h2&gt;
&lt;p&gt;In this activity, we will learn how to create multi (3) band images. We will also learn how to perform some basic raster calculations (known as raster math in the GIS world).&lt;/p&gt;

&lt;h2 id=&quot;creating-a-raster-stack-in-r&quot;&gt;1. Creating a Raster Stack in R&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&quot;http://neondataskills.org/HDF5/Imaging-Spectroscopy-HDF5-In-R/&quot;&gt;previous activity&lt;/a&gt;, we exported a subset of the NEON Reflectance data from a HDF5 file. In this activity, we will create a full color image using 3 (red, green and blue - RGB) bands. We will follow many of the steps we followed in the &lt;a href=&quot;http://neondataskills.org/HDF5/Imaging-Spectroscopy-HDF5-In-R/&quot;&gt;intro to working with hyperspectral data activity&lt;/a&gt;. These steps included loading required packages, reading in our file and viewing the file structure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Load required packages
library(raster)
library(rhdf5)
#Read in H5 file
#f &amp;lt;- &#39;/Users/lwasser/Documents/Conferences/1_DataWorkshop_ESA2014/HDF5File/SJER_140123_chip.h5&#39;
f &amp;lt;- &#39;/Users/law/Documents/data/SJER_140123_chip.h5&#39;
#View HDF5 file structure 
h5ls(f,all=T)
#r get spatial info and map info using the h5readAttributes function developed by Ted Hart
spinfo &amp;lt;- h5readAttributes(f,&quot;spatialInfo&quot;)

#Populate the raster image extent value. 
#get the map info, split out elements
mapInfo&amp;lt;-h5read(f,&quot;map info&quot;)
mapInfo&amp;lt;-unlist(strsplit(mapInfo, &quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll write a set of functions that will perform the processing that we did step by step in the &lt;a href=&quot;http://neondataskills.org/HDF5/Imaging-Spectroscopy-HDF5-In-R/&quot;&gt;intro to working with hyperspectral data activity&lt;/a&gt;. This will allow us to process multiple bands in bulk.&lt;/p&gt;

&lt;p&gt;The first function &lt;code&gt;getBandMat&lt;/code&gt; slices the HDF5 file, extracting the reflectance information for a specified band. It returns a matrix containing that band. To call this function, we would enter &lt;code&gt;getBandMat(fileObject, *BandNumber*)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#f: the hdf file
# band: the band you want to process
# returns: a matrix containing the reflectance data for the specific band
getBandMat &amp;lt;- function(f, band){
  	  out&amp;lt;- h5read(f,&quot;Reflectance&quot;,index=list(1:477,1:502,band))
  	  #Convert from array to matrix
  	  out &amp;lt;- (out[,,1])
  	  #transpose data to fix flipped row and column order 
  	  out &amp;lt;-t(out)
  #assign data ignore values to NA
  	  out[out &amp;gt; 14999] &amp;lt;- NA
  	  return(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next function, &lt;code&gt;band2rast&lt;/code&gt; takes the subsetted band matrix and creates a raster. It also calculates and sets both the raster extent and the CRS (coordinate reference system) for the raster. The call for this function would be &lt;code&gt;band2rast(fileObject, *BandNumber*)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;band2rast &amp;lt;- function(f,band){
  	  #define the raster including the CRS (taken from SPINFO)
  out &amp;lt;-  raster(getBandMat(f,band),crs=(spinfo$projdef))
  #define extents of the data using metadata and matrix attributes
  xMN=as.numeric(mapInfo[4])
  xMX=(xMN+(ncol(b34)))
  yMN=as.numeric(mapInfo[5]) 
  yMX=(yMN+(nrow(b34)))
  #set raster extent
  rasExt &amp;lt;- extent(xMN,xMX,yMN,yMX)
  #assign extent to raster
  extent(out) &amp;lt;- rasExt
  return(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last function, &lt;code&gt;stackList&lt;/code&gt; creates the final raster stack. A &lt;a href=&quot;http://www.inside-r.org/packages/cran/raster/docs/stack&quot; target=&quot;_blank&quot;&gt;raster stack&lt;/a&gt; is a set 1 or more rasters. If it contains multiple rasters, it uses a list which defines which bands (or dimensions in the Reflectance dataset) to grab and process. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## This function creates a stack of rasters from a list of rasters
stackList &amp;lt;- function(rastList){
  	  #add first raster to stack.
  	  masterRaster &amp;lt;- stack(rastList[[1]])
  	  #add additional layers to raster stack 
  	  for(i in 2:length(rastList)){
		masterRaster&amp;lt;-  addLayer(masterRaster,rastList[[i]])
  	  }
  	  return(masterRaster)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the functions are created, we can create our list of rasters. The list specifies which bands (or dimensions in our hyperspectral dataset) we want to include in our raster stack. Let’s start with a typical RGB (red, green, blue) combination. We will use bands 58, 34, and 19. &lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip - wavelengths and bands:&lt;/strong&gt; Remember that you can look at the wavelengths dataset to determine the center wavelength value for each band. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rgb &amp;lt;- list(58,34,19)
#lapply tells R to apply the function to each element in the list
rgb_rast &amp;lt;- lapply(rgb,band2rast, f = f)
#check out the properties or rgb_rast
#note that it displays properties of 3 rasters.
rgb_rast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://www.r-bloggers.com/using-apply-sapply-lapply-in-r/&quot; target=&quot;_blank&quot;&gt;More about Lapply here&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Next, add the names of the bands to the raster so we can easily keep track of the bands in the list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#add the band numbers as names to each raster in the raster list
names(rgb_rast) &amp;lt;- as.character(rgb)
#check properties of the raster list - note the band names
rgb_rast
### Plot one raster in the list to make sure things look OK.
plot(rgb_rast[[1]])
#create a raster stack from the list
rgb_stack &amp;lt;- stackList(rgb_rast)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let’s add the names of each band to our raster list. Then we can plot the bands&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Add band names to each raster in the stack
bandNames=paste(&quot;Band_&quot;,unlist(rgb),sep=&quot;&quot;)
for (i in 1:length(rgb_rast) ) {
  	  names(rgb_stack)[i]=bandNames[i]
}
#plot the stack	
plot(rgb_stack)
plotRGB(rgb_stack,r=1,g=2,b=3, scale=300, stretch = &quot;Lin&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;plotRGB&lt;/code&gt; function allows you to combine three bands to create an image. &lt;a href=&quot;http://www.inside-r.org/packages/cran/raster/docs/plotRGB&quot; target=&quot;_blank&quot;&gt;More on plotRGB here.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#write out final raster	
#note - you should be able to bring this tiff into any GIS program!

writeRaster(rgb_stack,file=&quot;test6.tif&quot;,overwrite=TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip - False color and near infrared images:&lt;/strong&gt; Use the band combinations listed at the top of this page to modify the raster list. What type of image do you get when you change the band values?&lt;/p&gt;

&lt;p&gt;If you want to play around a bit with this – try plotting the RGB image using different bands. Here are some suggestions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Color Infrared / False Color: rgb: (90,34,19)&lt;/li&gt;
  &lt;li&gt;SWIR, NIR,Red Band – rgb (152,90,58)&lt;/li&gt;
  &lt;li&gt;False Color: – rgb (363,246,55)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More on Band Combinations: &lt;a href=&quot;http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations&quot;&gt;http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt;&lt;strong&gt;A note about image stretching:&lt;/strong&gt; 
Notice that the scale is set to 300 on the RGB image that we plotted above. We can adjust this number and notice that the image gets darker - or lighter.&lt;/p&gt;

&lt;h2 id=&quot;plotting-our-data-on-a-map&quot;&gt;2. Plotting our data on a map.&lt;/h2&gt;
&lt;p&gt;We can plot the location of our image on a map of the US. For this we’ll use the lower left coordinates of the raster, extracted from the SPINFO group. Note that these coordinates are in latitude and longitude (geographic coordinates) rather than UTM coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Create a Map in R
library(maps)
map(database=&quot;state&quot;,region=&quot;california&quot;)
points(spinfo$LL_lat~spinfo$LL_lon,pch = 15)
#add title to map.
title(main=&quot;NEON Site Location in Southern California&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;raster-math---creating-ndvi-and-other-vegetation-indices-in-r&quot;&gt;3. Raster Math - Creating NDVI and other Vegetation Indices in R&lt;/h2&gt;
&lt;p&gt;In this last part, we will calculate some vegetation indices using raster math in R! We will start by creating NDVI or Normalized Difference Vegetation Index. &lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip - About NDVI:&lt;/strong&gt; NDVI is  a ratio between the near infrared (NIR) portion of the electromagnetic spectrum and the red portion of the spectrum. Please keep in mind that there are different ways to aggregate bands when using hyperspectral data. This example is using individual bands to perform the NDVI calculation. Using individual bands is not necessarily the best way to calculate NDVI from hyperspectral data! &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Calculate NDVI
#select bands to use in calculation (red, NIR)
ndvi_bands &amp;lt;- c(58,90)
#create raster list and then a stack using those two bands
ndvi_rast &amp;lt;- lapply(ndvi_bands,band2rast, f = f)
ndvi_stack &amp;lt;- stackList(ndvi_rast)
#calculate NDVI
NDVI &amp;lt;- function(x) {
  	  (x[,2]-x[,1])/(x[,2]+x[,1])
}
ndvi_calc &amp;lt;- calc(ndvi_stack,NDVI)
plot(ndvi_calc, main=&quot;NDVI for the NEON SJER Field Site&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure class=&quot;half&quot;&gt;
&lt;a href=&quot;/images/hyperspectral/NDVI.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/NDVI.png&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;/images/hyperspectral/EVI.png&quot;&gt;&lt;img src=&quot;/images/hyperspectral/EVI.png&quot; /&gt;&lt;/a&gt;
    
&lt;figcaption&gt;LEFT: NDVI for the NEON SJER field site, created in R. RIGHT: EVI for the NEON SJER field site created in R.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;extra-credit&quot;&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;IF you get done early, try any of the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Calculate EVI using the following formula : EVI&amp;lt;- 2.5 * ((b4-b3) / (b4 + 6 * b3- 7.5*b1 + 1))&lt;/li&gt;
  &lt;li&gt;Calculate NDNI using the following equation: log(1/p1510)-log(1/p1680)/ log(1/p1510)+log(1/p1680)&lt;/li&gt;
  &lt;li&gt;Explore the bands in the hyperspectral data. What happens if you average reflectance values across multiple red and NIR bands and then calculate NDVI?&lt;/li&gt;
&lt;/ol&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/HDF5/Create-Raster-Stack-Spectroscopy-HDF5-In-R/&quot;&gt;Creating a Raster Stack from Hyperspectral Imagery in HDF5 Format in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 13, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Activity: Creating A Square Buffer Around a Plot Centroid in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/working-with-field-data/Field-Data-Polygons-From-Centroids" />
  <id>http://localhost:4000/working-with-field-data/Creating-Square-Plot-Boundaries-From-Centroids-in-R</id>
  <published>2015-01-05T13:49:52-07:00</published>
  <updated>2015-01-05T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#about-this-activity&quot;&gt;About This Activity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-you-need&quot;&gt;What You Need&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#review-how-to-install-packages&quot;&gt;REVIEW: How to Install Packages&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#part-1---load-csv-setup-plots&quot;&gt;Part 1 - Load CSV, Setup Plots&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#part-2---create-spatial-polygons&quot;&gt;Part 2 - Create Spatial Polygons&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#part-3---export-to-shapefile&quot;&gt;Part 3 - Export to Shapefile&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h1 id=&quot;about-this-activity&quot;&gt;About This Activity&lt;/h1&gt;
&lt;p&gt;Sometimes we have a set of plot centroid (marking the center of a plot) values in x,y format. We need to derive the plot boundaries or edges of the plot, from the centroids. If the plot is a circle, we can generate the plot boundary using a buffer function in R or a GIS package. However, creating a SQUARE boundary around a centroid requires an alternate approach. This activity presents a way to create square polygons of a given radius (referring to half of the plots width), for each plot centroid location in a dataset.&lt;/p&gt;

&lt;p&gt;This activity requires a “.csv” (Comma Separated Value) file that contains the plot centroids in X,Y format and preferably some sort of unique plot ID. The data used in this activity were collected at the National Ecological Observatory Network field site in San Joaquin Experimental Range, California. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We’d Like to Thank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Special thanks to &lt;a href=&quot;http://stackoverflow.com/users/489704/jbaums&quot; target=&quot;_blank&quot;&gt; jbaums&lt;/a&gt; from StackOverflow for helping with the SpatialPolygons code!&lt;/p&gt;

&lt;h1 id=&quot;what-you-need&quot;&gt;What You Need&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;R or RStudio&lt;/li&gt;
  &lt;li&gt;A functioning thinking cap&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data to Download:&lt;/strong&gt; The plot centroid csv located &lt;a href=&quot;http://lwasser.github.io/data/SJERPlotCentroids.csv&quot; title=&quot;Centroid data for SJER&quot;&gt;HERE&lt;/a&gt; (right click to download)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Required R Packages:&lt;/strong&gt; the sp and rgdal packages.&lt;/li&gt;
  &lt;li&gt;Quick Hint: You need to first install the sp and rgdal packages before calling them in your code. Make sure they are installed or else calling them as a library won’t work.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;review-how-to-install-packages&quot;&gt;REVIEW: How to Install Packages&lt;/h2&gt;
&lt;p&gt;Use the code below to install the sp and rgdal packages. NOTE: you can just type this into the command line to install each package. Once a package is installed, you don’t have to install it again! &lt;a href=&quot;http://www.r-bloggers.com/installing-r-packages/&quot; target=&quot;_blank&quot;&gt;Read more about installing packages in R by R-bloggers.&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;install.packages&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;‘sp’&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
install.packages&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;‘rgdal’&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;part-1---load-csv-setup-plots&quot;&gt;Part 1 - Load CSV, Setup Plots&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#this code will create square &amp;quot;plots&amp;quot; of a user-defined radius from X,Y  centroids&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#first, load the sp and gdal libraries&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;sp&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;rgdal&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#be sure to set your working directory so you know where any code outputs are saved.&lt;/span&gt;
&lt;span class=&quot;kp&quot;&gt;setwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;~/SET-YOUR-DIRECTORY-HERE/1_DataWorkshop_ESA2014/ESAWorkshop_data&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#Make sure character strings don&amp;#39;t import as factors&lt;/span&gt;
&lt;span class=&quot;kp&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;stringsAsFactors&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#read in the NEON plot centroid data (downloaded above - &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#SJERPlotCentroids.csv)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#make sure this file has been saved in your working directory&lt;/span&gt;
centroids &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; read.csv&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;SJERPlotCentroids.csv&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The next piece of code sets the radius for the plots. This radius is used to calculate the vertex locations that define the plot perimeter. In this case, we will use a radius of 20m to create a 40 m x 40 m square plot. Radius is in METERS given the data are in the UTM coordinate reference system (CRS).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#set the radius for the plots
radius &amp;lt;- 20 #radius in meters

#define the plot boundaries based upon the plot radius. 
#NOTE: this assumes that plots are oriented North and are not rotated. 
#If the plots are rotated, you&#39;d need to do additional math to find 
#the corners.
yPlus &amp;lt;- centroids$northing+radius
xPlus &amp;lt;- centroids$easting+radius
yMinus &amp;lt;- centroids$northing-radius
xMinus &amp;lt;- centroids$easting-radius
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we will extract each plot’s unique ID from the centroids csv file. We will associate the centroid plot ID with the plot perimeter polygon that we create below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Extract the plot ID information. NOTE: because we set
#stringsAsFactor to false above, we can import the plot 
#ID&#39;s using the code below. If we didn&#39;t do that, our ID&#39;s would 
#come in as factors by default. 
#We&#39;d thus have to use the code ID=as.character(centroids$Plot_ID) 
ID=centroids$Plot_ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: When calculating the coordinates for the vertices, it is important to CLOSE the polygon. This means that a square will have 5 instead of 4 vertices. The fifth vertex is identical to the first vertex. Thus, by repeating the first vertex coordinate (xMinus,yPlus) the polygon will be closed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#calculate polygon coordinates for each plot centroid. 
square=cbind(xMinus,yPlus, xPlus,yPlus, xPlus,yMinus, xMinus,yMinus,xMinus,yPlus,xMinus,yPlus)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-2---create-spatial-polygons&quot;&gt;Part 2 - Create Spatial Polygons&lt;/h2&gt;
&lt;p&gt;Next, create Spatial Polygons. NOTE: this particular step is somewhat confusing. Please consider reading up on the SpatialPolygon object
in R. or check out the stack overflow thread that helped us sort out how this works. &lt;a href=&quot;http://stackoverflow.com/questions/26620373/spatialpolygons-creating-a-set-of-polygons-in-r-from-coordinates&quot; target=&quot;_blank&quot;&gt;Stack Overflow Thread&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note 1: Spatial polygons require a list of lists. Each list contains the xy coordinates of each vertex in the polygon - in order. This includes the closing vertex that we discussed above. So, remember, you’ll have to repeat the first vertex coordinate.&lt;/p&gt;

&lt;p&gt;Note 2: you can grab the CRS string from another file that has CRS information already. To do this, use the syntax: proj4string =CRS(as.character(YOU-DATA-HERE@crs)). So, for example if we imported a tiff called “canopy” that was in a UTM coordinate system, we could type proj4string-CRS(as.character(canopy@crs))&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Let’s Do this the efficient way - we will use the mapply function.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create spatial polygons
polys &amp;lt;- SpatialPolygons(mapply(function(poly, id) {
  xy &amp;lt;- matrix(poly, ncol=2, byrow=TRUE)
  Polygons(list(Polygon(xy)), ID=id)
}, split(square, row(square)), ID),proj4string=CRS(as.character(&quot;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;If the above doesn’t make sense, let’s try to less efficient way - using a loop&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The code below uses simpler R code contained within a loop. Please keep in mind that loops are less efficient to process your data. But this code might be easier for you to understand if you are newer to R.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#this is the inefficient way of doing this - using a for loop
#initialize the list
a &amp;lt;- vector(&#39;list&#39;, length(2))

#loop through each centroid value and create a polygon
for (i in 1:nrow(centroids)) {	   
  a[[i]]&amp;lt;-Polygons(list(Polygon(matrix(square[i, ], ncol=2, byrow=TRUE))), ID[i]) 
}

polys&amp;lt;-SpatialPolygons(a,proj4string=CRS(as.character(&quot;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-3---export-to-shapefile&quot;&gt;Part 3 - Export to Shapefile&lt;/h2&gt;
&lt;p&gt;Before you can export a shapefile, you need to convert the spatialpolygons to a spatial polygon data frame. Note: this is the step where you could add additional attribute data if you wanted to!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Create SpatialPolygonDataFrame -- this step is required to output multiple polygons.
polys.df &amp;lt;- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let’s check out the results before we export
	plot(polys.df, col=rainbow(50, alpha=0.5))&lt;/p&gt;

&lt;p&gt;writeOGR is a nice function as it writes not only the shapefile, but also the associated Coordinate Reference System (CRS) information IF it was identified when creating the SpatialPolygons object. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#write out the data
writeOGR(polys.df, &#39;.&#39;, &#39;sjerPlots2&#39;, &#39;ESRI Shapefile&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there you have it. Bring that shapefile into QGIS or whatever GIS package you prefer and have a look! Note that you could add additional attribute data to it as well!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/working-with-field-data/Field-Data-Polygons-From-Centroids&quot;&gt;Activity: Creating A Square Buffer Around a Plot Centroid in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on January 05, 2015.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Interactive Data Viz Using R, GGPLOT2 and PLOTLY]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/R/Plotly/" />
  <id>http://localhost:4000/R/plotly-R</id>
  <published>2014-12-06T13:49:52-07:00</published>
  <updated>2014-12-06T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;p&gt;NEON Remote Sensing Data compared to NEON Terrestrial Measurements for the SJER Field Site&lt;/p&gt;

&lt;iframe width=&quot;460&quot; height=&quot;293&quot; frameborder=&quot;0&quot; seamless=&quot;seamless&quot; scrolling=&quot;no&quot; src=&quot;https://plot.ly/~leahawasser/24.embed?width=460&amp;amp;height=293&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;The three plots below was generated using R code that harnesses the power of the &lt;code&gt;GGPLOT2&lt;/code&gt; and the &lt;code&gt;plotly&lt;/code&gt; packages. The plotly code utilizes the &lt;a href=&quot;http://ropensci.org/packages/&quot; target=&quot;_blank&quot;&gt;RopenSci &lt;code&gt;plotly&lt;/code&gt; packages - check them out!&lt;/a&gt; The data are NEON data collected from a flux tower at the Ordway Swisher field site. &lt;/p&gt;

&lt;iframe width=&quot;460&quot; height=&quot;345&quot; frameborder=&quot;0&quot; seamless=&quot;seamless&quot; scrolling=&quot;no&quot; src=&quot;https://plot.ly/~leahawasser/6.embed?width=460&amp;amp;height=345&quot;&gt;&lt;/iframe&gt;

&lt;iframe width=&quot;560&quot; height=&quot;420&quot; frameborder=&quot;0&quot; seamless=&quot;seamless&quot; scrolling=&quot;no&quot; src=&quot;https://plot.ly/~leahawasser/16.embed?width=800&amp;amp;height=600&quot;&gt;&lt;/iframe&gt;

&lt;iframe width=&quot;560&quot; height=&quot;420&quot; frameborder=&quot;0&quot; seamless=&quot;seamless&quot; scrolling=&quot;no&quot; src=&quot;https://plot.ly/~leahawasser/19.embed?width=800&amp;amp;height=600&quot;&gt;&lt;/iframe&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt; &lt;strong&gt;Data Tip&lt;/strong&gt; these plots were created using R &lt;code&gt;GGPLOT2&lt;/code&gt; and &lt;code&gt;plotly&lt;/code&gt; libraries. You can turn many plots that you in R into online interactive viz elements. You can also use python &lt;code&gt;matplotlib&lt;/code&gt; to create and publish visualizations.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/R/Plotly/&quot;&gt;Interactive Data Viz Using R, GGPLOT2 and PLOTLY&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on December 06, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Species Occurence maps]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/GIS/ArcGISOnline/" />
  <id>http://localhost:4000/GIS/ArcGISOnline-NEONData</id>
  <published>2014-12-06T13:49:52-07:00</published>
  <updated>2014-12-06T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;p&gt;The map below was created using small mammal data downloded from the NEON data portal. The last map represents soil N:P ratio derived using the NEON soil megapit data. Learn more about NEON &lt;a href=&quot;http://neoninc.org/science-design/collection-methods/soil-sensors-measurements&quot; target=&quot;_blank&quot;&gt;soils&lt;/a&gt; and &lt;a href=&quot;http://neoninc.org/science-design/collection-methods/terrestrial-organism-sampling&quot; target=&quot;_blank&quot;&gt;terrestrial &lt;/a&gt;sampling.&lt;/p&gt;

&lt;iframe width=&quot;800px&quot; height=&quot;600px&quot; src=&quot;https://neon.maps.arcgis.com/apps/MapSeries/?appid=969c8bd2aa5a4e4c97f808b78dfd093f&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/GIS/ArcGISOnline/&quot;&gt;Species Occurence maps&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on December 06, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Activity: Getting Started with the R Programming Language]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/R-Programming/Getting-Started-With-R/" />
  <id>http://localhost:4000/R-Programming/R-Basics-Getting-Started</id>
  <published>2014-11-04T13:49:52-07:00</published>
  <updated>2014-11-04T13:49:52-07:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#the-very-basics-of-r&quot;&gt;The Very Basics of R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#comments-in-r&quot;&gt;Comments in R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#introduction-to-r-and-rstudio&quot;&gt;Introduction to R and RStudio&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#basic-operations-in-r&quot;&gt;Basic Operations in R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#data-types-and-structures&quot;&gt;Data types and structures&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;p&gt;&lt;strong&gt;R Skill Level:&lt;/strong&gt; beginner&lt;/p&gt;

&lt;h1 id=&quot;the-very-basics-of-r&quot;&gt;The Very Basics of R&lt;/h1&gt;

&lt;p&gt;R is a versatile, open source programming language that was specifically designed for data analysis. R is extremely useful both for statistics and analyzing data. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cool Fact: R was inspired by the programming language &lt;a href=&quot;http://en.wikipedia.org/wiki/S_(programming_language)&quot; target=&quot;_blank&quot;&gt;S&lt;/a&gt;.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;R is:
* Open source software under a &lt;a href=&quot;http://en.wikipedia.org/wiki/GNU_General_Public_License&quot; target=&quot;_blank&quot;&gt;General Public License (GPL)&lt;/a&gt;.&lt;br /&gt;
* A good alternative to commercial analysis tools. R has over 5,000 user contributed packages and is widely used both in academia and industry.&lt;br /&gt;
* Available on all platforms.&lt;br /&gt;
* Not just for statistics, but also general purpose programming. &lt;br /&gt;
* Supported by a large and growing community of peers.  &lt;/p&gt;

&lt;h1 id=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/h1&gt;

&lt;h2 id=&quot;comments-in-r&quot;&gt;Comments in R&lt;/h2&gt;
&lt;p&gt;Use &lt;code&gt;#&lt;/code&gt; signs to comment. Comment liberally in your R scripts. Anything to the right of a &lt;code&gt;#&lt;/code&gt; is ignored by R.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#this is a comment. there is a line of code below it.
a &amp;lt;- 1+2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;drop-the-equals-sign---assignment-operator&quot;&gt;Drop the Equals Sign - Assignment operator&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; is the assignment operator. Assigns values on the right to objects on the left. Mostly similar to &lt;code&gt;=&lt;/code&gt; but not always. Learn to use &lt;code&gt;&amp;lt;-&lt;/code&gt; as it is good programming practice. Using &lt;code&gt;=&lt;/code&gt; in place of &lt;code&gt;&amp;lt;-&lt;/code&gt; can lead to issues down the line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a&amp;lt;- 1+2 #this is preferred syntax over:
a= 1+2 #this is NOT preferred syntax
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;packages-in-r&quot;&gt;Packages in R&lt;/h3&gt;
&lt;p&gt;R comes with a set of functions or commands that perform particular sets of calculations. For example, in the equation 1+2, R knows that the “+” means to add the two numbers, 1 and 2 together. However, you can expand the capability of R by installing packages that contain suites of functions and compiled code that you can also use in your code.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/R/Packages-In-R/&quot; title=&quot;Packages in R&quot;&gt;Learn more about packages in R - Adapted from Software Carpentry, HERE.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction-to-r-and-rstudio&quot;&gt;Introduction to R and RStudio&lt;/h2&gt;

&lt;p&gt;You can use R or RStudio to write your code. Some people prefer R studio as it provides a graphic interface where you can see what objects have been created and you can also set variables like your working directory, using menu options.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Let’s start by learning about R studio and R.&lt;br /&gt;
&lt;a href=&quot;http://dss.princeton.edu/training/RStudio101.pdf&quot;&gt;Learn More about R Studio&lt;/a&gt;
* Console, Scripts, Environments, Plots
* Avoid using shortcuts. 
* Code and workflow is more reproducible if we can document everything that we do.
* Our end goal is not just to “do stuff” but to do it in a way that anyone can easily and exactly replicate our workflow and results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;basic-operations-in-r&quot;&gt;Basic Operations in R&lt;/h2&gt;
&lt;p&gt;Let’s take a few moments to play with R. You can get output from R simply by typing in math&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 + 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[1] 8&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12/7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[1] 1.714&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or by typing words, with the command &lt;code&gt;writeLines()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;writeLines(“hello world”)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can assign our results to an object, if we give it a name&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a &amp;lt;- 60 * 60
hours &amp;lt;- 365 * 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;result&lt;/em&gt; of the operation on the right hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; is &lt;em&gt;assigned&lt;/em&gt; to an object with the name specified on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt;. The &lt;em&gt;result&lt;/em&gt; could be any type of R object, including your own functions.&lt;/p&gt;

&lt;h3 id=&quot;list-all-objects-in-the-environment&quot;&gt;List All objects in the environment&lt;/h3&gt;
&lt;p&gt;Some of the same commands we learned from the command line can be used in R.
List objects in your current environment&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove objects from your current environment.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 5
rm(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove all objects from your current environment. Typing &lt;code&gt;x&lt;/code&gt; on the console will give you an error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm(list = ls())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;data-types-and-structures&quot;&gt;Data types and structures&lt;/h2&gt;

&lt;h3 id=&quot;understanding-basic-data-types-in-r&quot;&gt;Understanding basic data types in R&lt;/h3&gt;

&lt;p&gt;To make the best of the R language, you’ll need a strong understanding of the basic data types and data structures and how to operate on those.&lt;/p&gt;

&lt;p&gt;This understanding is because these are the objects you will manipulate on a day-to-day basis in R. Dealing with object conversions is one of the most common sources of frustration for beginners.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Everything&lt;/strong&gt; in R is an object.&lt;/p&gt;

&lt;p&gt;R has 6 (although we will not discuss the raw class for this workshop) atomic vector types.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;character&lt;/li&gt;
  &lt;li&gt;numeric (real or decimal)&lt;/li&gt;
  &lt;li&gt;integer&lt;/li&gt;
  &lt;li&gt;logical&lt;/li&gt;
  &lt;li&gt;complex&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By &lt;em&gt;atomic&lt;/em&gt;, we mean the vector only holds data of a single type.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;character&lt;/strong&gt;: &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;swc&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;numeric&lt;/strong&gt;: &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;15.5&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;integer&lt;/strong&gt;: &lt;code&gt;2L&lt;/code&gt; (the &lt;code&gt;L&lt;/code&gt; tells R to store this as an integer)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;logical&lt;/strong&gt;: &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;complex&lt;/strong&gt;: &lt;code&gt;1+4i&lt;/code&gt; (complex numbers with real and imaginary parts)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R provides many functions to examine features of vectors and other objects, for example&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;typeof()&lt;/code&gt; - what is it?  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;length()&lt;/code&gt; - how long is it? What about two dimensional objects?  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;attributes()&lt;/code&gt; - does it have any metadata?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Let’s look at some examples:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- &quot;dataset&quot;
typeof(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] &quot;character&quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;attributes(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y &amp;lt;- 1:10
y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1]  1  2  3  4  5  6  7  8  9 10&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] &quot;integer&quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;length(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] 10&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;z &amp;lt;- as.numeric(y)
z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1]  1  2  3  4  5  6  7  8  9 10&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof(z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] &quot;double&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;R has many &lt;strong&gt;data structures&lt;/strong&gt;. These include&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atomic vector&lt;/li&gt;
  &lt;li&gt;list&lt;/li&gt;
  &lt;li&gt;matrix&lt;/li&gt;
  &lt;li&gt;data frame&lt;/li&gt;
  &lt;li&gt;factors&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vectors&quot;&gt;Vectors&lt;/h3&gt;

&lt;p&gt;A vector is the most common and basic data structure in R and is the workhorse of R. Technically, vectors can be one of two types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atomic vectors&lt;/li&gt;
  &lt;li&gt;lists&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;although the term “vector” most commonly refers to the atomic types not to lists.&lt;/p&gt;

&lt;h4 id=&quot;atomic-vectors&quot;&gt;Atomic Vectors&lt;/h4&gt;

&lt;p&gt;A vector is a collection of elements that are most commonly &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;logical&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;numeric&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can create an empty vector with &lt;code&gt;vector()&lt;/code&gt;. (By default the mode is &lt;code&gt;logical&lt;/code&gt;. You can be more explicit as shown in the examples below.) It is more common to use direct constructors such as &lt;code&gt;character()&lt;/code&gt;, &lt;code&gt;numeric()&lt;/code&gt;, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- vector()

#Create vector with a length and type
vector(&quot;character&quot;, length = 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create character vector with length of 5
character(5)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#numeric vector length=5
numeric(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] 0 0 0 0 0&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#logical vector length=5
logical(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] FALSE FALSE FALSE FALSE FALSE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Some othe examples of creating objects in R follow:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(1, 2, 3)
x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] 1 2 3&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;length(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OUTPUT: [1] 3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt; is a numeric vector. These are the most common kind. They are numeric objects and are treated as double precision real numbers (they can store decimal points). To explicitly create integers (no decimal points), add an &lt;code&gt;L&lt;/code&gt; to each (or &lt;em&gt;coerce&lt;/em&gt; to the integer type using &lt;code&gt;as.integer()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#a numeric vector with integers (L)
x1 &amp;lt;- c(1L, 2L, 3L)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also have logical vectors. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y &amp;lt;- c(TRUE, TRUE, FALSE, FALSE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally you can have character vectors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;z &amp;lt;- c(&quot;Sarah&quot;, &quot;Tracy&quot;, &quot;Jon&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Examine your vector&lt;/strong&gt;  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof(z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] “character”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;length(z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT [1] 3 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class(z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] “character”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str(z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:  chr [1:3] “Sarah” “Tracy” “Jon”&lt;/p&gt;

&lt;p&gt;Question: Do you see a property that’s common to all these vectors above?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Add elements&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;z &amp;lt;- c(z, &quot;Annette&quot;)
z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] “Sarah”   “Tracy”   “Jon”     “Annette”&lt;/p&gt;

&lt;p&gt;More examples of vectors&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(0.5, 0.7)
x &amp;lt;- c(TRUE, FALSE)
x &amp;lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)
x &amp;lt;- 9:100
x &amp;lt;- c(1 + (0+0i), 2 + (0+4i))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create vectors as a sequence of numbers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;series &amp;lt;- 1:10
seq(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:  [1]  1  2  3  4  5  6  7  8  9 10&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;seq(from = 1, to = 10, by = 0.1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:&lt;br /&gt;
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3&lt;br /&gt;
 [15]  2.4  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7&lt;br /&gt;
 [29]  3.8  3.9  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1&lt;br /&gt;
 [43]  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5&lt;br /&gt;
 [57]  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9&lt;br /&gt;
 [71]  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3&lt;br /&gt;
 [85]  9.4  9.5  9.6  9.7  9.8  9.9 10.0  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inf&lt;/code&gt; is infinity. You can have either positive or negative infinity.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] Inf&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; means Not a Number. It’s an undefined value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] NaN&lt;/p&gt;

&lt;p&gt;Objects can have &lt;strong&gt;attributes&lt;/strong&gt;. Attribues are part of the object. These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;names&lt;/li&gt;
  &lt;li&gt;dimnames&lt;/li&gt;
  &lt;li&gt;dim&lt;/li&gt;
  &lt;li&gt;class&lt;/li&gt;
  &lt;li&gt;attributes (contain metadata)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also glean other attribute-like information such as length (works on vectors and lists) or number of characters (for character strings).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;length(1:10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] 10&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nchar(&quot;Software Carpentry&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] 18&lt;/p&gt;

&lt;h4 id=&quot;what-happens-when-you-mix-types&quot;&gt;What happens when you mix types?&lt;/h4&gt;

&lt;p&gt;When you mix types, R will create a resulting vector that is the least common denominator. The coercion will move towards the one that’s easiest to &lt;strong&gt;coerce&lt;/strong&gt; to.&lt;/p&gt;

&lt;p&gt;Guess what the following do without running them first&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xx &amp;lt;- c(1.7, &quot;a&quot;)
xx &amp;lt;- c(TRUE, 2)
xx &amp;lt;- c(&quot;a&quot;, TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is called implicit coercion. You can also coerce vectors explicitly using the &lt;code&gt;as.&amp;lt;class_name&amp;gt;&lt;/code&gt;. Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;as.numeric(&quot;1&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;as.character(1:2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT [1] “1” “2”&lt;/p&gt;

&lt;h3 id=&quot;matrix&quot;&gt;Matrix&lt;/h3&gt;

&lt;p&gt;In R matrices are an extension of the numeric or character vectors. They are not a separate type of object but simply an atomic vector with dimensions; the number of rows and columns.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m &amp;lt;- matrix(nrow = 2, ncol = 2)
m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;p&gt;[,1] [,2]
[1,]   NA   NA
[2,]   NA   NA&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dim(m)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT [1] 2 2&lt;/p&gt;

&lt;p&gt;Matrices in R are filled column-wise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m &amp;lt;- matrix(1:6, nrow = 2, ncol = 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other ways to construct a matrix. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m &amp;lt;- 1:10
dim(m) &amp;lt;- c(2, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Dim&lt;/code&gt; takes a vector and transform into a matrix with 2 rows and 5 columns. Another way to shape your matrix is to bind columns &lt;code&gt;cbind()&lt;/code&gt; or rows &lt;code&gt;rbind()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 1:3
y &amp;lt;- 10:12
cbind(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT
.    x  y
[1,] 1 10
[2,] 2 11
[3,] 3 12&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rbind(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT
[,1] [,2] [,3]
x    1    2    3
y   10   11   12&lt;/p&gt;

&lt;p&gt;You can also use the &lt;code&gt;byrow&lt;/code&gt; argument to specify how the matrix is filled. From R’s own documentation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mdat &amp;lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE)
mdat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:
.     [,1] [,2] [,3]
[1,]    1    2    3
[2,]   11   12   13&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;

&lt;p&gt;In R lists act as containers. Unlike atomic vectors, the contents of a list are not restricted to a single mode and can encompass any mixture of data types. Lists are sometimes called generic vectors, because the elements of a list can by of any type of R object, even lists containing further lists. This property makes them fundamentally different from atomic vectors.&lt;/p&gt;

&lt;p&gt;A list is a special type of vector. Each element can be a different type.&lt;/p&gt;

&lt;p&gt;Create lists using &lt;code&gt;list()&lt;/code&gt; or coerce other objects using &lt;code&gt;as.list()&lt;/code&gt;. An empty list of the required length can be created using &lt;code&gt;vector()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(1, &quot;a&quot;, TRUE, 1 + (0+4i))
x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;p&gt;[[1]]
[1] 1&lt;/p&gt;

&lt;p&gt;[[2]]
[1] “a”&lt;/p&gt;

&lt;p&gt;[[3]]
[1] TRUE&lt;/p&gt;

&lt;p&gt;[[4]]
[1] 1+4i&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- vector(&quot;list&quot;, length = 5)  ## empty list
length(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] 5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x[[1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:  NULL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 1:10
x &amp;lt;- as.list(x)
length(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] 10&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What is the class of &lt;code&gt;x[1]&lt;/code&gt;?&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What about &lt;code&gt;x[[1]]&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;xlist &amp;lt;- list(a = “Karthik Ram”, b = 1:10, data = head(iris))
 xlist&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;p&gt;$a
[1] “Ben Smiley”&lt;/p&gt;

&lt;p&gt;$b
[1]  1  2  3  4  5  6  7  8  9 10&lt;/p&gt;

&lt;p&gt;$data&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Sepal.Length&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Sepal.Width&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Petal.Length&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Petal.Width&lt;/th&gt;
      &lt;th&gt;Species&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.4&lt;/td&gt;
      &lt;td&gt;setosa&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;What is the length of this object? What about its structure?&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Lists can be extremely useful inside functions. You can “staple” together lots of different kinds of results into a single object that a function can return.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A list does not print to the console like a vector. Instead, each element of the list starts on a new line.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elements are indexed by double brackets. Single brackets will still return a(nother) list.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;factors&quot;&gt;Factors&lt;/h3&gt;

&lt;p&gt;Factors are special vectors that represent categorical data. Factors can be ordered or unordered and are important for modelling functions such as &lt;code&gt;lm()&lt;/code&gt; and &lt;code&gt;glm()&lt;/code&gt; and also in &lt;code&gt;plot()&lt;/code&gt; methods. Once created, factors can only contain a pre-defined set values, known as &lt;em&gt;levels&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Factors are stored as integers that have labels associated the unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood. You need to be careful when treating them like strings. Some string methods will coerce factors to strings, while others will throw an error.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Sometimes factors can be left unordered. Example: male, female.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other times you might want factors to be ordered (or ranked). Example: low, medium, high.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Underlying it’s represented by numbers 1, 2, 3.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;They are better than using simple integer labels because factors are what are called self describing. male and female is more descriptive than 1s and 2s. Helpful when there is no additional metadata.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Which is male? 1 or 2? You wouldn’t be able to tell with just integer data. Factors have this information built in.&lt;/p&gt;

&lt;p&gt;Factors can be created with &lt;code&gt;factor()&lt;/code&gt;. Input is often a character vector.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;))
x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT:
 [1] yes no  no  yes yes
 Levels: no yes&lt;/p&gt;

&lt;p&gt;&lt;code&gt;table(x)&lt;/code&gt; will return a frequency table counting the number of elements in each level.&lt;/p&gt;

&lt;p&gt;If you need to convert a factor to a character vector, simply use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;as.character(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] “yes” “no”  “no”  “yes” “yes”&lt;/p&gt;

&lt;p&gt;To convert a factor to a numeric vector, go via a character. Compare&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f &amp;lt;- factor(c(1, 5, 10, 2))
as.numeric(f)  ## wrong!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] 1 3 4 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;as.numeric(as.character(f))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT [1]  1  5 10  2  &lt;/p&gt;

&lt;p&gt;In modeling functions, it is important to know what the baseline level is. This is the first factor but by default the ordering is determined by alphanumerical order of elements. You can change this by speciying the &lt;code&gt;levels&lt;/code&gt; (another option is to use the function &lt;code&gt;relevel()&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;))
x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT&lt;br /&gt;
 [1] yes no  yes
 Levels: yes no&lt;/p&gt;

&lt;h3 id=&quot;data-frame&quot;&gt;Data frame&lt;/h3&gt;

&lt;p&gt;A data frame is a very important data type in R. It’s pretty much the &lt;em&gt;de facto&lt;/em&gt; data structure for most tabular data and what we use for statistics.  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A data frame is a special type of list where every element of the list has same length.  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data frames can have additional attributes such as &lt;code&gt;rownames()&lt;/code&gt;, which can be useful for annotating data, like &lt;code&gt;subject_id&lt;/code&gt; or &lt;code&gt;sample_id&lt;/code&gt;. But most of the time they are not used.  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some additional information on data frames:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Usually created by &lt;code&gt;read.csv()&lt;/code&gt; and &lt;code&gt;read.table()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Can convert to matrix with &lt;code&gt;data.matrix()&lt;/code&gt; (preferred) or &lt;code&gt;as.matrix()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Coercion will be forced and not always what you expect.&lt;/li&gt;
  &lt;li&gt;Can also create with &lt;code&gt;data.frame()&lt;/code&gt; function.&lt;/li&gt;
  &lt;li&gt;Find the number of rows and columns with &lt;code&gt;nrow(dat)&lt;/code&gt; and &lt;code&gt;ncol(dat)&lt;/code&gt;, respectively.&lt;/li&gt;
  &lt;li&gt;Rownames are usually 1, 2, …, n.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;creating-data-frames-by-hand&quot;&gt;Creating data frames by hand&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dat &amp;lt;- data.frame(id = letters[1:10], x = 1:10, y = 11:20)
dat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT&lt;br /&gt;
    id  x  y&lt;br /&gt;
 1   a  1 11&lt;br /&gt;
 2   b  2 12&lt;br /&gt;
 3   c  3 13&lt;br /&gt;
 4   d  4 14&lt;br /&gt;
 5   e  5 15&lt;br /&gt;
 6   f  6 16&lt;br /&gt;
 7   g  7 17&lt;br /&gt;
 8   h  8 18&lt;br /&gt;
 9   i  9 19&lt;br /&gt;
 10  j 10 20  &lt;/p&gt;

&lt;h4 id=&quot;useful-data-frame-functions&quot;&gt;Useful data frame functions&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;head()&lt;/code&gt; - shown first 6 rows&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tail()&lt;/code&gt; - show last 6 rows&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dim()&lt;/code&gt; - returns the dimensions&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;nrow()&lt;/code&gt; - number of rows&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ncol()&lt;/code&gt; - number of columns&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str()&lt;/code&gt; - structure of each column&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;names()&lt;/code&gt; - shows the &lt;code&gt;names&lt;/code&gt; attribute for a data frame, which gives the column names.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See that it is actually a special list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;is.list(iris)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] TRUE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class(iris)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] “data.frame”&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Dimensions&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Homogenous&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Heterogeneous&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1-D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;atomic vector&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;list&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2_D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;matrix&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;data frame&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;indexing&quot;&gt;Indexing&lt;/h3&gt;

&lt;p&gt;Vectors have positions, these positions are ordered and can be called using &lt;code&gt;object[index]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;letters[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OUTPUT: [1] “b”&lt;/p&gt;

&lt;h3 id=&quot;functions&quot;&gt;Functions&lt;/h3&gt;

&lt;p&gt;A function is an R object that takes inputs to perform a task. 
Functions take in information and may return desired outputs.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output &amp;lt;- name_of_function(inputs)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 1:10
y &amp;lt;- sum(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;help&quot;&gt;Help&lt;/h3&gt;

&lt;p&gt;All functions come with a help screen. 
It is critical that you learn to read the help screens since they provide important information on what the function does, 
how it works, and usually sample examples at the very bottom.&lt;/p&gt;

&lt;h3 id=&quot;get-new-functions&quot;&gt;Get new functions&lt;/h3&gt;

&lt;p&gt;To install any package use &lt;code&gt;install.packages()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;install.packages(“ggplot2”)  ## install the ggplot2 package&lt;/p&gt;

&lt;p&gt;You can’t ever learn all of R, but you can learn how to build a program and how to find help to do the things that you want to do.&lt;/p&gt;

&lt;p&gt;Let’s get hands-on.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/R-Programming/Getting-Started-With-R/&quot;&gt;Activity: Getting Started with the R Programming Language&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on November 04, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Working With Functions in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/Using-R/Working-With-Functions" />
  <id>http://localhost:4000/Using-R/R-Basics-Of-Functions</id>
  <published>2014-10-29T14:49:52-06:00</published>
  <updated>2014-10-29T14:49:52-06:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#creating-functions&quot;&gt;Creating Functions&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#objectives&quot;&gt;Objectives&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#getting-started&quot;&gt;Getting Started&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#composing-functions&quot;&gt;Composing Functions&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lets-build-a-function&quot;&gt;Let’s Build a Function&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h1 id=&quot;creating-functions&quot;&gt;Creating Functions&lt;/h1&gt;

&lt;p&gt;Sometimes we need to perform a calculation or a set of calculations, multiple times in our code. For example, we might need to convert units from Celcius to Kelvin, across multiple datasets and through time. &lt;/p&gt;

&lt;p&gt;We could write out the equation over and over in our code. OR we could chose to build a function that allows us to repeat several operations with a single command. This activity will focus on creating functions in R.&lt;/p&gt;

&lt;h2 id=&quot;objectives&quot;&gt;Objectives&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Define a function that takes parameters (input values).&lt;/li&gt;
  &lt;li&gt;Return a value from a function.&lt;/li&gt;
  &lt;li&gt;???Test and debug a function.???&lt;/li&gt;
  &lt;li&gt;Set default values for function parameters.&lt;/li&gt;
  &lt;li&gt;Explain why we should divide programs into small, single-purpose functions.&lt;/li&gt;
  &lt;li&gt;Learn how to define a Function&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;Let’s start by defining a function &lt;code&gt;fahr_to_kelvin&lt;/code&gt; that converts temperature values from Fahrenheit to Kelvin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fahr_to_kelvin &amp;lt;- function(temp) {
    kelvin &amp;lt;- ((temp - 32) * (5/9)) + 273.15
    kelvin
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the syntax used to define this function:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;FunctionNameHere &amp;lt;- function(InputVariable-or-variables-here)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The definition begins with the name of your new function, which is followed by the call to make it a &lt;code&gt;function&lt;/code&gt; and a parenthesized list of parameter names. The parameters are the input values that the function will use to perform any calculations. In this case, the input might be the temperature value that we wish to convert from fahrenheit to kelvin. You can have as many input parameters as you would like (but too many might be bad style). The body, or implementation, is surrounded by curly braces &lt;code&gt;{ }&lt;/code&gt;. In many languages, the body of the function - the statements that are executed when it runs - must be indented, typically using 4 spaces. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HINT: While it is not mandatory to indent your code 4 spaces within a function, it is  strongly recommended as good practice!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function. The last line within the function is what R will evaluate as a returning value. Remember that the last line has to be a command that will print to the screen, and not an object definition, otherwise the function will return nothing - it will work, but will provide no output. For example, let’s try running our function. Calling our own function is no different from calling any other function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fahr_to_kelvin(32)
paste(&#39;boiling point of water:&#39;, fahr_to_kelvin(212))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ve successfully called the function that we defined, and we have access to the value that we returned. However, it the function was redefined as follows&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fahr_to_kelvin &amp;lt;- function(temp) {
    kelvin &amp;lt;- ((temp - 32) * (5/9)) + 273.15
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now typing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fahr_to_kelvin(32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will return nothing. However try assigning the function to a variable “a”.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a &amp;lt;- fahr_to_kelvin(32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, what happens when you type &lt;code&gt;a&lt;/code&gt; ?&lt;/p&gt;

&lt;p&gt;==============================&lt;/p&gt;

&lt;h2 id=&quot;composing-functions&quot;&gt;Composing Functions&lt;/h2&gt;

&lt;p&gt;Now that we’ve seen how to turn Fahrenheit into Kelvin, it’s easy to turn Kelvin into Celsius:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kelvin_to_celsius &amp;lt;- function(temp) {
    Celsius &amp;lt;- temp - 273.15
	Celsius
}

paste(&#39;absolute zero in Celsius:&#39;, kelvin_to_celsius(0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What about converting Fahrenheit to Celsius? We could write out the formula, but we don’t need to. Instead, we can compose the two functions we have already created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fahr_to_celsius &amp;lt;- function(temp) {
	temp_k &amp;lt;- fahr_to_kelvin(temp)
	result &amp;lt;- kelvin_to_celsius(temp_k)
    result
}

paste(&#39;freezing point of water in Celsius:&#39;, fahr_to_celsius(32.0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is our first taste of how larger programs are built: we define basic operations, then combine them in ever-large chunks to get the effect we want. 
Real-life functions will usually be larger than the ones shown here—typically half a dozen to a few dozen lines—but they shouldn’t ever be much longer than that, or the next person who reads it won’t be able to understand what’s going on. &lt;/p&gt;

&lt;h2 id=&quot;lets-build-a-function&quot;&gt;Let’s Build a Function&lt;/h2&gt;

&lt;p&gt;So now we’ve learned the basics of building functions in R. Let’s create one of our own. The function that we will build, &lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/Using-R/Working-With-Functions&quot;&gt;Working With Functions in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on October 29, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[Activity: Installing & Updating Packages in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/R/Packages-In-R/" />
  <id>http://localhost:4000/R/R-Basics-Of-Packages</id>
  <published>2014-10-27T14:49:52-06:00</published>
  <updated>2014-10-27T14:49:52-06:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#what-youll-need&quot;&gt;What you’ll need&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-youll-learn-here&quot;&gt;What you’ll Learn Here&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#about-packages-in-r&quot;&gt;About Packages in R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#installing-packages-in-r&quot;&gt;Installing Packages in R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#what-packages-are-installed-on-your-machine&quot;&gt;What Packages are installed On Your Machine?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#updating-packages&quot;&gt;Updating Packages&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#activity&quot;&gt;Activity&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h1 id=&quot;what-youll-need&quot;&gt;What you’ll need&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;R or R studio loaded on your computer&lt;/li&gt;
  &lt;li&gt;A functioning thinking cap.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;what-youll-learn-here&quot;&gt;What you’ll Learn Here&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;The basics of what a package is in R&lt;/li&gt;
  &lt;li&gt;How to install a package in R&lt;/li&gt;
  &lt;li&gt;How to call upon (use) that installed package in R&lt;/li&gt;
  &lt;li&gt;How to update a package in R&lt;/li&gt;
  &lt;li&gt;How to see what packages are installed on your computer &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;about-packages-in-r&quot;&gt;About Packages in R&lt;/h2&gt;

&lt;p&gt;Packages are collections of R functions, data, and compiled code in a well-defined format. When you install a package it gives you access to a set of commands that are not available in the base R set of functions. The directory where packages are stored is called the library. R comes with a standard set of packages. Others are available for download and installation. Once installed, they have to be loaded into the session to be used.&lt;/p&gt;

&lt;h3 id=&quot;more-on-packages&quot;&gt;More on Packages&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.statmethods.net/interface/packages.html&quot; target=&quot;_blank&quot;&gt;Definition adapted from the Quick-R website&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.r-bloggers.com/installing-r-packages/&quot; target=&quot;_blank&quot;&gt;Read more about installing packages in R by R-bloggers.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;installing-packages-in-r&quot;&gt;Installing Packages in R&lt;/h2&gt;
&lt;p&gt;The website that hosts many of the R packages is called &lt;a href=&quot;http://cran.r-project.org/&quot; target=&quot;_blank&quot;&gt;“CRAN”&lt;/a&gt;. &lt;code&gt;install.packages(&quot;package-name&quot;)&lt;/code&gt; will download a package from one of the &lt;a href=&quot;http://cran.r-project.org/&quot; target=&quot;_blank&quot;&gt;CRAN mirrors where the packages are saved&lt;/a&gt; assuming that a binary (or set of installation files) is available for your operating system. If you have not set a preferred CRAN mirror in your options(), then a menu will pop up asking you to choose a location from which you’d like to install your packages.&lt;/p&gt;

&lt;p&gt;To install packages, use the code: &lt;code&gt;install.packages(&#39;package-Name-Here)&lt;/code&gt; So, for example, you can use the code below to install the sp and rgdal packages. NOTE: you can just type this into the command line of R to install each package. Once a package is installed, you don’t have to install it again! &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(‘raster’)
install.packages(‘sp’)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, by installing a package onto your machine, you are half way there. If you want to USE the package - or the functions contained in that package - in your code, you need to first CALL it. So, to call the raster package that we installed above, we would type &lt;code&gt;library(raster)&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;In the code, it would look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(sp)
library(dplyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;what-packages-are-installed-on-your-machine&quot;&gt;What Packages are installed On Your Machine?&lt;/h2&gt;
&lt;p&gt;Good question - let’s find out. Use &lt;code&gt;old.packages()&lt;/code&gt; to list all your locally installed packages that are now out of date. &lt;code&gt;update.packages()&lt;/code&gt; will update all packages in the known libraries interactively. This can take a while if you haven’t done it recently. To update everything without any user intervention, use the &lt;code&gt;ask = FALSE&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;http://www.rstudio.com/&quot; target=&quot;_blank&quot;&gt;RStudio&lt;/a&gt;, you can also manage packages using Tools -&amp;gt; Install Packages.&lt;/p&gt;

&lt;h2 id=&quot;updating-packages&quot;&gt;Updating Packages&lt;/h2&gt;
&lt;p&gt;Sometimes packages are updated by the users who created them. Updating packages can sometimes make changes to both the package and also to how your code runs. If you already have a lot of code in R, be cautious about updating packages. Otherwise let’s just go ahead and update our packages so things are up to date.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{r, eval=FALSE}
update.packages(ask = FALSE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;code&gt;old.packages()&lt;/code&gt; to list all your locally-installed packages that are now out of date. &lt;code&gt;update.packages()&lt;/code&gt; will update all packages in the known libraries interactively. This can take a while if you haven’t done it recently. To update everything without any user intervention, use the &lt;code&gt;ask = FALSE&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;r
update.packages(ask = FALSE)
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;activity&quot;&gt;Activity&lt;/h2&gt;

&lt;p&gt;Following this activity, you should be able to do the following – so have at it!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Check to see if the dplyr package is installed on your computer&lt;/li&gt;
  &lt;li&gt;Next, install the “dplyr” package in R. if it’s already installed, consider a different package such as ggplot2.&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/R/Packages-In-R/&quot;&gt;Activity: Installing & Updating Packages in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on October 27, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[The Basics of LiDAR - Light Detection and Ranging - Remote Sensing]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/remote-sensing/1_About-LiDAR-Data-Light-Detection-and-Ranging_Activity1/" />
  <id>http://localhost:4000/remote-sensing/1_About-LiDAR-Data-Light-Detection-and-Ranging_Activity1</id>
  <published>2014-07-21T14:49:52-06:00</published>
  <updated>2014-07-21T14:49:52-06:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#lidar-background&quot;&gt;Lidar Background&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#why-lidar&quot;&gt;Why LiDAR&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#how-lidar-works-1&quot;&gt;How LiDAR Works&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#how-scientists-use-lidar-data&quot;&gt;How Scientists Use LiDAR Data&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#discrete-vs-full-waveform-lidar&quot;&gt;Discrete vs. Full Waveform LiDAR&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lidar-file-formats-&quot;&gt;LiDAR File Formats **&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#additional-resources&quot;&gt;Additional Resources:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;LiDAR or &lt;strong&gt;Li&lt;/strong&gt;ght &lt;strong&gt;D&lt;/strong&gt;etection &lt;strong&gt;a&lt;/strong&gt;nd &lt;strong&gt;R&lt;/strong&gt;anging is an active remote sensing system that can be used to measure vegetation height across wide areas. This page will introduce fundamental lidar concepts including:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What LiDAR data are.&lt;/li&gt;
  &lt;li&gt;The key attributes of LiDAR data.&lt;/li&gt;
  &lt;li&gt;How LiDAR data are used to measure trees. &lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt;
&lt;img src=&quot;https://farm4.staticflickr.com/3913/14532371197_a17d52e010.jpg&quot; alt=&quot;LiDAR data collected at the Soaproot Saddle site by the National Ecological Observatory Network Airborne Observation Platform (NEON AOP) - available on https://www.flickr.com/photos/126239263@N04/sets&quot; /&gt;
&lt;figcaption&gt;LiDAR data collected at the Soaproot Saddle site by the National Ecological Observatory Network Airborne Observation Platform (NEON AOP) - available on https://www.flickr.com/photos/126239263@N04/sets&lt;/figcaption&gt;
&lt;a href=&quot;&quot;&gt;View Image on Flikr&lt;/a&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;lidar-background&quot;&gt;Lidar Background&lt;/h1&gt;

&lt;h3 id=&quot;the-story-of-lidar-data-video---on-youtube&quot;&gt;The Story of LiDAR Data video - On YouTube&lt;/h3&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/m7SXoFv6Sdc?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;how-lidar-works&quot;&gt;How LiDAR Works&lt;/h3&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/EYbhNSUnIdU?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;lets-get-started---key-concepts-to-review&quot;&gt;Let’s Get Started - Key Concepts to Review&lt;/h3&gt;

&lt;h2 id=&quot;why-lidar&quot;&gt;Why LiDAR&lt;/h2&gt;

&lt;p&gt;Scientists often need to characterize vegetation over large regions. We use tools that can estimate key characteristics over large areas because we don’t have the resources to measure each and every tree. These tools often use remote methods. Remote sensing means that we aren’t actually physically measuring things with our hands, we are using sensors which capture information about a landscape and record things that we can use to estimate conditions and characteristics.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;../../images/ScalingTrees_NatGeo.jpg&quot; alt=&quot;Conventional on the ground methods to measure trees are resource intensive and limit the amount of vegetation that can be characterized! Photo: National Geographic&quot; /&gt;
&lt;figcaption&gt;Conventional on the ground methods to measure trees are resource intensive and limit the amount of vegetation that can be characterized! Photo: National Geographic&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;To measure vegetation across large areas we need remote sensing methods that can take many measurements, quickly using automated sensors. These measurements can  be used to estimate forest structure across larger areas. LiDAR, or light detection ranging (sometimes also referred to as active laser scanning) is one remote sensing method that can be used to map structure including vegetation height, density and other characteristics across a region. LiDAR directly measures the height and density of vegetation on the ground making it an ideal tool for scientists studying vegetation over large areas.&lt;/p&gt;

&lt;h2 id=&quot;how-lidar-works-1&quot;&gt;How LiDAR Works&lt;/h2&gt;

&lt;p&gt;LIDAR is an &lt;strong&gt;active remote sensing&lt;/strong&gt; system. An active system means that the system itself generates energy - in this case light - to measure things on the ground. In a LiDAR system, light is emitted from a rapidly firing laser. You can imagine, light quickly strobing from a laser light source. This light travels to the ground and reflects off of things like buildings and tree branches. The reflected light energy then returns to the LiDAR sensor where it is recorded.&lt;/p&gt;

&lt;p&gt;A LiDAR system measures the time it takes for emitted light to travel  to the ground and back. That time is used to calculate distance traveled. Distance traveled is then converted to elevation. These measurements are made using the key components of a lidar system including a GPS that identifies the X,Y,Z location of the light energy and an IMU that provides the orientation of the plane in the sky.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/uSESVm59uDQ?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;how-light-energy-is-used-to-measure-trees&quot;&gt;How Light Energy Is Used to Measure Trees&lt;/h3&gt;

&lt;p&gt;Light energy is a collection of photons. As photon that make up light moves towards the ground, they hit objects such as branches on a tree. Some of the light reflects off of those objects and returns to the sensor. If the object is small, and there are gaps surrounding it that allow light to pass through, some light continues down towards the ground. Because some photons reflect off of things like branches but others continue down towards the ground, multiple reflections may be recorded from one pulse of light. &lt;/p&gt;

&lt;p&gt;The distribution of energy that returns to the sensor creates what we call a waveform. The amount of energy that returned to the LiDAR sensor is known as “intensity”. The areas where more photons or more light energy returns to the sensor create peaks in the distribution of energy. Theses peaks in the waveform often represent objects on the ground like - a branch, a group of leaves or a building. &lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;../../images/Waveform.PNG&quot; alt=&quot;An example LiDAR waveform. Image: National Ecological Observatory Network, Boulder, CO&quot; /&gt;
&lt;figcaption&gt;An example LiDAR waveform. Image: National Ecological Observatory Network, Boulder, CO&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;how-scientists-use-lidar-data&quot;&gt;How Scientists Use LiDAR Data&lt;/h2&gt;
&lt;p&gt;There are many different uses for LiDAR data. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LiDAR data classically have been used to derive high resolution elevation data &lt;image: low=&quot;&quot; vs=&quot;&quot; high=&quot;&quot; resolution=&quot;&quot; dem=&quot;&quot;&gt;&lt;/image:&gt;&lt;/li&gt;
  &lt;li&gt;LiDAR data have also been used to derive information about vegetation structure including
    &lt;ul&gt;
      &lt;li&gt;Canopy Height&lt;/li&gt;
      &lt;li&gt;Canopy Cover &lt;/li&gt;
      &lt;li&gt;Leaf Area Index&lt;/li&gt;
      &lt;li&gt;Vertical Forest Structure&lt;/li&gt;
      &lt;li&gt;Species identification (in less dense forests with high point density LiDAR)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
&lt;img src=&quot;http://farm4.staticflickr.com/3883/14718736222_190e498006.jpg&quot; alt=&quot;LiDAR data have historically been used to generate high resolution elevation datasets.&quot; /&gt;
&lt;figcaption&gt;LiDAR data have historically been used to generate high resolution elevation datasets.&lt;/figcaption&gt;
&lt;a href=&quot;&quot;&gt;View Image on Flikr&lt;/a&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;img src=&quot;http://farm6.staticflickr.com/5584/14696841986_586d180bee.jpg&quot; alt=&quot;Cross section showing LiDAR data and an example profile of a landscape.&quot; /&gt;
&lt;figcaption&gt;Cross section showing LiDAR data and an example profile of a landscape.&lt;/figcaption&gt;
&lt;a href=&quot;&quot;&gt;View Image on Flikr&lt;/a&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;discrete-vs-full-waveform-lidar&quot;&gt;Discrete vs. Full Waveform LiDAR&lt;/h2&gt;
&lt;p&gt;A waveform or distribution of light energy is what returns to the LiDAR sensor. However, this return may be recorded in two different ways.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A &lt;strong&gt;Discrete Return LiDAR System&lt;/strong&gt; records individual (discrete) points for the peaks in the waveform curve. Discrete return LiDAR systems, identify peaks and record a point at each peak location in the waveform curve. These discrete or individual points are called returns. A discrete system may record 1-4 (and sometimes more) returns from each laser pulse.&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;Full Waveform LiDAR System&lt;/strong&gt; records a distribution of returned light energy. Full waveform LiDAR data are thus more complex to process however they can often capture more information compared to discrete return LiDAR systems.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lidar-file-formats-&quot;&gt;LiDAR File Formats **&lt;/h2&gt;
&lt;p&gt;Whether it is collected as discrete points or full waveform, most often LiDAR data are available as discrete points. A collection of discrete return LiDAR points is known as a LiDAR point cloud.&lt;/p&gt;

&lt;p&gt;The commonly used file format to store LIDAR point cloud data is called .las which is a format supported by the Americal Society of Photogrammetry and Remote Sensing (ASPRS). Recently, the &lt;a href=&quot;http://www.laszip.org/&quot;&gt;.laz&lt;/a&gt; format has been  developed by Martin isenberg of LasTools. Laz is a highly compressed version of .las.&lt;/p&gt;

&lt;h3 id=&quot;lidar-data-attributes-xy-z-intensity-and-classification&quot;&gt;LiDAR Data Attributes: X,Y, Z, Intensity and Classification&lt;/h3&gt;
&lt;p&gt;LiDAR data attributes can vary, depending upon how the data were collected and processed. You can determine what attributes are available for each lidar point by looking at the metadata. All lidar data points will have an associated X,Y location and Z (elevation values). Most lidar data points will have an intensity value, representing the amount of light energy recorded by the sensor.&lt;/p&gt;

&lt;p&gt;Some lidar data will also be “classified”. Classification of lidar point clouds is an additional processing step. Classification simply represents the type of object that the laser return reflected off of. So if the light energy reflected off of a tree, it might be classified as “vegetation”. And if it reflected off of the ground, it might be classified as “ground”.&lt;/p&gt;

&lt;p&gt;Some lidar data  will be classified as “ground / non ground”. Some datasets will be further processed to determine which points reflected off of buildings and other infrastructure. Some lidar data will be classified according to the vegetation type.   &lt;/p&gt;

&lt;h3 id=&quot;exploring-3d-lidar-data-in-a-free-online-viewer&quot;&gt;Exploring 3D LIDAR data in a free Online Viewer&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://neondataskills.org/remote-sensing/2_Lidar-Point-Cloud-Online-Data-Viz-Activity/&quot;&gt;Check out our activity that uses a free online lidar data viewer to view NEON LiDAR data!&lt;/a&gt;. The Plas.io viewer used in this activity was developed by Martin Isenberg of Las Tools and his colleagues.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A LiDAR system uses a laser + a gps and IMU to estimate the heights of objects on the ground.&lt;/li&gt;
  &lt;li&gt;Discrete LiDAR data is generated from waveforms - and each point represent peak energy points along the returned energy.&lt;/li&gt;
  &lt;li&gt;Discrete LiDAR points contain an x, y and z value. the z value is what is used to generate height.&lt;/li&gt;
  &lt;li&gt;LiDAR data can be used to estimate tree height and even canopy cover using various methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;additional-resources&quot;&gt;Additional Resources:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;What is the  &lt;a href=&quot;http://www.asprs.org/Committee&quot; title=&quot;las file format: &quot;&gt;las file format&lt;/a&gt;-*&lt;/li&gt;
  &lt;li&gt;General/LASer-LAS-File-Format-Exchange-Activities.html&lt;/li&gt;
  &lt;li&gt;What is Discrete Return lidar (ppt)&lt;/li&gt;
  &lt;li&gt;What is full waveform LiDAR (ppt)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://laspy.readthedocs.org/en/latest/tut_background.html&quot;&gt;las: python ingest&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.asprs.org/a/society/committees/standards/asprs_las_spec_v13.pdf&quot;&gt;las v1.3 specs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;use-images-from-the-lidar-data-image-gallery-in-your-presentations--teaching&quot;&gt;Use Images From The LiDAR Data Image Gallery In Your Presentations &amp;amp; Teaching!&lt;/h3&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;500px&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://flickrit.com/slideshowholder.php?height=75&amp;amp;size=big&amp;amp;setId=72157648481541867&amp;amp;caption=true&amp;amp;theme=1&amp;amp;thumbnails=1&amp;amp;transition=1&amp;amp;layoutType=responsive&amp;amp;sort=0&quot;&gt;&lt;/iframe&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/remote-sensing/1_About-LiDAR-Data-Light-Detection-and-Ranging_Activity1/&quot;&gt;The Basics of LiDAR - Light Detection and Ranging - Remote Sensing&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on July 21, 2014.&lt;/p&gt;</content>
</entry>

<entry>
  <title type="html"><![CDATA[R: Create a Canopy Height Model from LiDAR derived Rasters (grids) in R]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/using-lidar-data/1_lidar_derived-data-products/" />
  <id>http://localhost:4000/using-lidar-data/R-LiDAR_derived-data-products</id>
  <published>2014-07-18T14:49:52-06:00</published>
  <updated>2014-07-18T14:49:52-06:00</updated>
  <author>
    <name>NEON EDUCATION</name>
    <uri>http://localhost:4000</uri>
    <email>lwasser@neoninc.org</email>
  </author>
  <content type="html">&lt;section id=&quot;table-of-contents&quot; class=&quot;toc&quot;&gt;
  &lt;header&gt;
    &lt;h3&gt;Contents&lt;/h3&gt;
  &lt;/header&gt;
&lt;div id=&quot;drawer&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#background&quot;&gt;Background&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part-1-creating-a-lidar-derived-canopy-height-model-chm&quot;&gt;Part 1. Creating a LiDAR derived Canopy Height Model (CHM)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part-2-how-does-our-chm-data-compare-to-field-measured-tree-heights&quot;&gt;Part 2. How does our CHM data compare to field measured tree heights?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#working-with-extracted-data&quot;&gt;Working with extracted data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extracting-descriptive-stats-from-insitu-data&quot;&gt;Extracting descriptive stats from Insitu Data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#test-your-skills&quot;&gt;Test Your Skills&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/section&gt;
&lt;!-- /#table-of-contents --&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;NEON (National Ecological Observatory Network) will provide derived LiDAR products as one of its many free ecological data products. One data product that NEON will provide is a digital surface model which represents the top of the surface elevation of objects on the earth. These products will come in a &lt;a href=&quot;http://trac.osgeo.org/geotiff/&quot; title=&quot;geotiff (read more)&quot;&gt;geotiff&lt;/a&gt; format, which is simply a raster format, that is spatially located on the earth. Geotiffs can be easily accessed using the &lt;code&gt;raster&lt;/code&gt; package in R.&lt;/p&gt;

&lt;p&gt;A common first analysis using LiDAR data is to derive top of the canopy height values from the LiDAR data. These values are often used to track changes in forest structure over time, to calculate biomass, and even LAI. Let’s dive into the basics of working with raster formatted lidar data in R! Before we begin, make sure you’ve downloaded the data required to run the code below.&lt;/p&gt;

&lt;div id=&quot;objectives&quot;&gt;
&lt;h3&gt;What you&#39;ll need&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;R or R studio loaded on your computer &lt;/li&gt;
&lt;li&gt;GDAL libraries installed on you computer. &lt;a href=&quot;https://www.youtube.com/watch?v=ZqfiZ_J_pQQ&amp;amp;list=PLLWiknuNGd50NbvZhydbTqJJh5ZRkjuak&quot; target=&quot;_blank&quot;&gt;Click here for videos on installing GDAL on a MAC and a PC.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

###Data to Download

Download the raster and *insitu* collected vegetation structure data:

&lt;a href=&quot;http://www.neonhighered.org/Data/LidarActivity/CHM_InSitu_Data.zip&quot; class=&quot;btn btn-success&quot;&gt; DOWNLOAD NEON  Sample NEON LiDAR Data&lt;/a&gt;

&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE: these data are available in full, for no charge, but by request, &lt;a href=&quot;http://data.neoninc.org/airborne-data-request&quot; title=&quot;AOP data&quot;&gt;from the NEON data portal&lt;/a&gt;.&lt;/p&gt;

  &lt;p&gt;Before walking through this activity, you may want to review the DSM, DTM and CHM discussion in the Raster LiDAR Data here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;required-r-packages&quot;&gt;Required R Packages&lt;/h3&gt;
&lt;p&gt;Please make sure the following packages are installed: Raster, sp, dplyr. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/R/Packages-In-R/&quot; title=&quot;Packages in R&quot;&gt;More on Packages in R - Adapted from Software Carpentry.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(‘raster’)
install.packages(‘sp’)
install.packages(‘dplyr’)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-1-creating-a-lidar-derived-canopy-height-model-chm&quot;&gt;Part 1. Creating a LiDAR derived Canopy Height Model (CHM)&lt;/h2&gt;
&lt;p&gt;In this activity, we will create a Canopy Height Model. Remember that the canopy height model, represents the actual heights of the trees on the ground. And we can derive the CHM by subtracting the ground elevation from the elevation of the top of the surface (or the tops of the trees). &lt;/p&gt;

&lt;p&gt;To begin the CHM creation, we will call the raster libraries in R and import the lidar derived digital surface model (DSM). Then we will import and plot the DSM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Because we will be exporting data in this activity, let&#39;s set the
#working directory before we go any further. The working directory 
#will determine where data are saved.
setwd(&quot;~/Conferences/1_DataWorkshop_ESA2014/ESAWorkshop_data&quot;)    

#Import DSM into R 
library(raster)
	
#IMPORTANT - the path to your DSM data may be different than the 
#path below.  
dsm_f &amp;lt;- &quot;CHANGE-THIS-TO-PATH-ON-YOUR-COMPUTER/DigitalSurfaceModel/SJER2013_DSM.tif&quot;

dsm &amp;lt;- raster(dsm_f)
## See info about the raster.
dsm
plot(dsm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we will import the Digital Terrain Model (DTM). Remember that the DTM represents the ground (terrain) elevation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import the digital terrain model
dtm_f &amp;lt;- &quot;CHANGE-THIS-TO-PATH-ON-YOUR-COMPUTER/DigitalTerrainModel/SJER2013_DTM.tif&quot;
dtm &amp;lt;- raster(dtm_f)
plot(dtm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we can create the Canopy Height Model (CHM). Remember that the CHM is simply the difference between the DSM and the DTM. So, we can perform some basic raster math to accomplish this. You might perform the SAME raster math in a GIS package like &lt;a href=&quot;http://www.qgis.org/en/site/&quot; title=&quot;QGIS&quot;&gt;QGIS&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Create a function that performs this raster math. Canopy height 
#is dsm - dtm
canopyCalc &amp;lt;- function(x, y) {
  return(x - y)
  }

#use the function to create the final CHM
#then plot it.
#you could use the overlay function here chm &amp;lt;- overlay(dsm,dtm,fun = canopyCalc)
#but you can also just perform matrix math to get the same output.
chm2 &amp;lt;- canopyCalc(dsm,dtm)
plot(chm)

#write out the CHM in tiff format. We can look at this in any GIS software.
#note that the code below places the output in an &quot;outputs&quot; folder. 
#you need to create this folder or else you will get an error.
writeRaster(chm,&quot;outputs/chm.tiff&quot;,&quot;GTiff&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woo hoo! We’ve now successfully created a canopy height model using basic raster math - in R! We can bring the chm.tiff file into QGIS (or any GIS) and look at it.  &lt;/p&gt;

&lt;h2 id=&quot;part-2-how-does-our-chm-data-compare-to-field-measured-tree-heights&quot;&gt;Part 2. How does our CHM data compare to field measured tree heights?&lt;/h2&gt;

&lt;p&gt;So now we have a canopy height model. however, how does that dataset compare to our laboriously collected, field measured height data? Let’s see.&lt;/p&gt;

&lt;p&gt;For this activity, we have two csv (comma separate value) files. The first file contains plot centroid location information (X,Y) where we measured trees. The second file contains our vegetation structure data for each plot. Let’s start by plotting the plot locations (in red) on a map. &lt;/p&gt;

&lt;p&gt;We will need to convert the plot centroids to a spatial points dataset in R. To do this we’ll need two additional packages - the spatial package - &lt;a href=&quot;http://cran.r-project.org/web/packages/sp/index.html&quot; title=&quot;R sp package&quot;&gt;sp&lt;/a&gt; - and &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/index.html&quot; title=&quot;dplyr&quot;&gt;dplyr&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Let’s get started!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#load needed libraries
library(sp)
library(dplyr)

#import the centroid data and the vegetation structure data
options(stringsAsFactors=FALSE)
centroids &amp;lt;- read.csv(&quot;data/SJERPlotCentroids.csv&quot;)
insitu_dat &amp;lt;- read.csv(&quot;data/D17_2013_vegStr.csv&quot;)

#Overlay the centroid points and the stem locations on the CHM plot

#for example, cex = point size 
points(centroids$easting,centroids$northing, pch=19, cex = 2,col = 2)
points(insitu_dat$easting,insitu_dat$northing, pch=19, cex=.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;HINT: type in &lt;code&gt;help(points)&lt;/code&gt; to read about the options for plotting points.
Also, to see a list of pch values (symbols), check out &amp;lt;a href=”http://www.endmemo.com/program/R/pchsymbols.php” target=_blank”&amp;gt;this website.&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;spatial-data-need-a-coordinate-reference-system---crs&quot;&gt;Spatial Data Need a Coordinate Reference System - CRS&lt;/h3&gt;

&lt;p&gt;Next, assign a CRS to our insitu data. The CRS is information that allows a program like QGIS to determine where the data are located, in the world. &lt;a href=&quot;http://www.sco.wisc.edu/coordinate-reference-systems/coordinate-reference-systems.html&quot; target=&quot;_blank&quot;&gt;Read more about CRS here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this case, we know these data are all in the same projection.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HINT: to find out what projection our CHM is in, Type &lt;code&gt;chm@crs&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#make spatial points object using the CRS (coordinate 
#reference system) from the CHM and apply it to our plot centroid data.
centroid_sp &amp;lt;- SpatialPoints(centroids[,4:3],proj4string =CRS(as.character(chm@crs)) )
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;extract-cmh-data-within-20-m-radius-of-each-plot-centroid&quot;&gt;Extract CMH data within 20 m radius of each plot centroid.&lt;/h3&gt;

&lt;p&gt;There are a few ways to go about this task. If your plots are circular, then the extract tool will do the job! However, you might need to use a shapefile that contains the plot boundaries OR perhaps your plot boundaries are rectangular. Several variations to complete this task are described below.&lt;/p&gt;

&lt;h3 id=&quot;variation-1-extract-plot-data-using-circle-20m-radius-plots&quot;&gt;Variation 1: Extract Plot Data Using Circle: 20m Radius Plots&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#Insitu sampling took place within 40m x 40m square plots so we use a 20m radius.	
#Note that below will return a list, so we can extract via lapply
cent_ovr &amp;lt;- extract(chm,centroid_sp,buffer = 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;variation-2-extract-chm-values-using-a-shapefile&quot;&gt;Variation 2: Extract CHM values Using a Shapefile&lt;/h3&gt;

&lt;p&gt;If your plot boundaries are saved in a shapefile, you can use the code below. There are two shapefiles in the folder named “PlotCentroid_Shapefile” within the zip file that you downloaded at the top of this page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#extract CHM data using polygon boundaries from a shapefile
squarePlot &amp;lt;- readShapePoly(&quot;InSitu_Data/SJERPlotCentroids_Buffer.shp&quot;)
cent_ovr &amp;lt;- extract(chm, squarePlot, weights=FALSE, fun=max)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;variation-3-derive-square-plot-boundaries-then-chm-values-using-a-shapefile&quot;&gt;Variation 3: Derive Square Plot boundaries, then CHM values Using a Shapefile&lt;/h3&gt;
&lt;p&gt;For see how to extract square plots using a plot centroid value, check out the &lt;a href=&quot;../../working-with-field-data/Field-Data-Polygons-From-Centroids/&quot; title=&quot;Polygons&quot;&gt;extracting square shapes activity.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;working-with-extracted-data&quot;&gt;Working with extracted data&lt;/h2&gt;
&lt;p&gt;Using one of the methods above, we have created the &lt;code&gt;centre_ovr&lt;/code&gt; object in R. This object contains all of the lidar CHM pixel values contained within our plot boundaries. Next, we will create a new dataframe by pulling the maximum value found within our plots.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;centroids$overlay &amp;lt;- unlist(lapply(cent_ovr,max))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;extracting-descriptive-stats-from-insitu-data&quot;&gt;Extracting descriptive stats from Insitu Data&lt;/h2&gt;
&lt;p&gt;Now, there are two ways to extract stats from a dataset. The first option is to write each line out. &lt;/p&gt;

&lt;h3 id=&quot;option-1---extracting-data-using-several-lines-of-code&quot;&gt;Option 1 - Extracting Data Using Several Lines of Code&lt;/h3&gt;

&lt;p&gt;First select plots that are also represented in our centroid layer. Quick test - how many plots are in the centroid folder?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insitu_inCentroid &amp;lt;- insitu_dat %.% filter(plotid %in% centroids$Plot_ID)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, list out plot id results. how many are there?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unique(insitu_inCentroid$plotid) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, find the max stem height value for each plot. We will compare this value to the max CHM value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insitu_maxStemHeight &amp;lt;- insit_inCentroid %.% group_by(plotid) %.% summarise(max = max(stemheight))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;option-2---extracting-data-using-one-line-of-code&quot;&gt;Option 2 - Extracting Data Using one Line of Code!&lt;/h3&gt;
&lt;p&gt;We can be super tricky and combine the above steps into one line of code. See below how this is done. To do this, we can take full advantage of the dplyr package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#find the max and 95th percentile value for all trees within each plot 
insitu &amp;lt;- insitu_dat %.% filter(plotid %in% centroids$Plot_ID) %.% group_by(plotid) %.% summarise(quant = quantile(stemheight,.95), max = max(stemheight))

#assign the final output to a column in our centroids object
centroids$insitu &amp;lt;- insitu$max
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;plot-data-chm-vs-measured&quot;&gt;Plot Data (CHM vs Measured)&lt;/h3&gt;
&lt;p&gt;Create the  final plot that compares in situ max tree height to CHM derived max height.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ggplot(centroids,aes(x=overlay, y =insitu )) + geom_point() + theme_bw() + ylab(&quot;Maximum measured height&quot;) + xlab(&quot;Maximum LiDAR pixel&quot;)+geom_abline(intercept = 0, slope=1)+xlim(0, max(centroids[,6:7])) + ylim(0,max(centroids[,6:7]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another option – A regression plot. Explore with GGPLOT options. Customize your plot.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#plot with regression fit
p &amp;lt;- ggplot(centroids,aes(x=chmMax, y =insitu )) + geom_point() + 
    ylab(&quot;Maximum Measured Height&quot;) + xlab(&quot;Maximum LiDAR Height&quot;)+
    geom_abline(intercept = 0, slope=1)+
    geom_smooth(method=lm) +
    xlim(0, max(centroids[,6:7])) + ylim(0,max(centroids[,6:7])) 

p + theme(panel.background = element_rect(colour = &quot;grey&quot;)) + ggtitle(&quot;LiDAR CHM Derived vs Measured Tree Height&quot;) +
  theme(plot.title=element_text(family=&quot;sans&quot;, face=&quot;bold&quot;, size=20, vjust=1.9)) +
  theme(axis.title.y = element_text(family=&quot;sans&quot;, face=&quot;bold&quot;, size=14, angle=90, hjust=0.54, vjust=1)) +
  theme(axis.title.x = element_text(family=&quot;sans&quot;, face=&quot;bold&quot;, size=14, angle=00, hjust=0.54, vjust=-.2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your final plot should look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chmPlot.png&quot; alt=&quot;CHM Plot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have now successfully created a canopy height model using lidar data AND compared lidar derived vegetation height, within plots, to actual measured tree height data!&lt;/p&gt;

&lt;h1 id=&quot;test-your-skills&quot;&gt;Test Your Skills&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Create a plot of LiDAR 95th percentile value vs &lt;em&gt;insitu&lt;/em&gt; max height. Or Lidar 95th percentile vs &lt;em&gt;insitu&lt;/em&gt; 95th percentile.&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/using-lidar-data/1_lidar_derived-data-products/&quot;&gt;R: Create a Canopy Height Model from LiDAR derived Rasters (grids) in R&lt;/a&gt; was originally published by NEON EDUCATION at &lt;a href=&quot;http://localhost:4000&quot;&gt;Work with Data - NEON Education&lt;/a&gt; on July 18, 2014.&lt;/p&gt;</content>
</entry>


</feed>
